# Лабораторная работа №1: Основы Composer и автозагрузка

## Информация о работе

| Параметр | Значение |
|---|---|
| Тема | Основы Composer и автозагрузка классов |
| Зависимости | PHP ^8.3, Composer |
| Стандарты | PSR-4 |

---

## Цели работы

В ходе данной лабораторной работы необходимо освоить инструменты управления зависимостями в PHP и механизмы автоматической загрузки классов. Работа разделена на две логические части: в первой части студенты создадут проект с нуля, настроят `composer.json` и научатся устанавливать, обновлять и удалять внешние библиотеки; во второй части будет реализована автозагрузка собственных классов по стандарту PSR-4 с подробным объяснением каждого шага.

---

## Теоретическая справка

### Что такое Composer и зачем он нужен?

Composer — это инструмент управления зависимостями для языка PHP. Его роль в экосистеме PHP аналогична роли `npm` в мире JavaScript или `pip` в Python: он позволяет декларативно описать, какие библиотеки требуются вашему проекту, и автоматически установить их с учётом совместимости версий.

Представьте себе ситуацию без Composer. Допустим, вам нужна библиотека для работы с электронной почтой. Вы скачиваете её с GitHub, кладёте в папку `libs/` своего проекта. Однако эта библиотека сама зависит от другой библиотеки — например, для работы с SHA-256 хешами. Теперь вы скачиваете и вторую библиотеку. Проходит несколько месяцев, библиотека для почты выходит в новой версии, и вы не знаете, совместима ли она с той версией SHA-256, которая у вас уже установлена. Другой разработчик присоединяется к проекту, но скачивает немного другие версии — и у него всё ломается. Composer решает все эти проблемы автоматически.

Центральным файлом любого проекта, использующего Composer, является `composer.json`. Именно в нём описывается всё: имя проекта, его зависимости, настройки автозагрузки, минимальный уровень стабильности пакетов и многое другое. Этот файл — единственный источник правды о том, из чего состоит ваш проект.

Помимо `composer.json` существует файл `composer.lock`. Он создаётся автоматически при первой установке зависимостей и содержит *точные* версии всех пакетов (включая транзитивные — те, что являются зависимостями ваших зависимостей). Если `composer.json` — это *рецепт* (что установить), то `composer.lock` — это *снимок* (что именно установлено прямо сейчас). Файл `composer.lock` необходимо хранить в репозитории, чтобы все члены команды работали с абсолютно одинаковыми версиями библиотек.

### Что такое автозагрузка (autoloading)?

В ранних версиях PHP для использования класса из другого файла необходимо было явно подключить этот файл через `require` или `include`. Например:

```php
require_once 'models/User.php';
require_once 'services/GreeterService.php';
require_once 'utils/MathHelper.php';

$user = new User('Анна', 'anna@example.com');
```

В небольшом проекте это терпимо. Но когда проект растёт, и файлов становится десятки, а потом и сотни, поддерживать список подключений вручную становится невозможно. Вы постоянно забываете подключить нужный файл, порядок подключения начинает иметь значение, и любое рефакторинг — например, перемещение файла в другую папку — требует обновления всех строк `require` по всему проекту.

Автозагрузка — это механизм, при котором PHP автоматически загружает файл с классом в тот момент, когда этот класс впервые используется в коде. Разработчику не нужно думать о порядке подключения файлов — достаточно один раз подключить загрузчик, и далее всё работает само.

Стандарт **PSR-4** задаёт простое и однозначное правило соответствия между пространством имён класса и его местоположением на диске. Формулируется это правило так: *пространство имён класса должно соответствовать структуре директорий, в которых он находится*. Например, если класс имеет полное имя `App\Models\User`, а базовая директория для пространства имён `App` — это `src/`, то файл с этим классом должен лежать по пути `src/Models/User.php`. Не по какому-либо другому пути — именно по этому, и никак иначе.

### Что такое пространства имён (namespaces)?

Пространство имён — это способ организации кода, позволяющий избежать конфликтов имён между классами из разных библиотек. Представьте: вы используете две библиотеки, и в обеих есть класс с именем `Logger`. Без пространств имён PHP не будет знать, какой именно `Logger` использовать, и возникнет ошибка. С пространствами имён одно принадлежит `Vendor1\Logger`, а другое — `Vendor2\Logger` — это полностью разные классы, несмотря на одинаковое «locальное» имя.

Пространство имён объявляется первой строкой файла (после открывающего тега PHP):

```php
<?php

namespace App\Models;
```

После этой строки все классы, определённые в данном файле, автоматически принадлежат пространству имён `App\Models`.

---

## Часть 1. Создание проекта и работа с зависимостями

### Задание 1.1. Инициализация проекта

Создадим директорию для проекта и инициализируем в ней Composer.

```bash
mkdir composer-lab && cd composer-lab
composer init
```

После вызова `composer init` Composer задаст ряд вопросов в интерактивном режиме. Отвечайте следующим образом:

| Вопрос | Ответ |
|---|---|
| Package name | `student/composer-lab` |
| Description | `Лабораторная работа по Composer` |
| Author | Введите своё имя и почту (или нажмите Enter для пропуска) |
| Minimum stability | `stable` |
| Interactive dependencies | `no` (зависимости добавим руками ниже) |

После завершения в директории появится файл `composer.json`. Откроем его:

```json
{
    "name": "student/composer-lab",
    "description": "Лабораторная работа по Composer",
    "type": "project",
    "require": {},
    "authors": [
        {
            "name": "Ваше имя",
            "email": "ваша@почта.com"
        }
    ],
    "require-dev": {},
    "minimum-stability": "stable",
    "prefer-stable": true
}
```

Разберём структуру этого файла по полям:

**`name`** — уникальный идентификатор пакета в формате `vendor/package`. Слово до слеша — имя автора или организации, после слеша — имя пакета. Этот идентификатор используется Composer для идентификации пакета на Packagist (главный репозиторий PHP-пакетов) и в зависимостях других проектов.

**`description`** — краткое текстовое описание проекта. Используется на Packagist для отображения информации о пакете.

**`type`** — тип пакета. Значение `project` означает, что это конечное приложение, а не библиотека. Это влияет на то, как Composer обрабатывает пакет: пакеты типа `project` не могут быть зависимостями других проектов.

**`require`** — раздел для зависимостей, необходимых на продакшн-сервере. Пока пуст — заполним его на следующем шаге.

**`require-dev`** — зависимости для разработки и тестирования. Эти пакеты не устанавливаются на сервере при запуске `composer install --no-dev`. Типичные примеры — инструменты анализа кода (PHPStan, Psalm), фреймворки тестирования (PHPUnit).

**`minimum-stability`** — минимально допустимый уровень стабильности зависимостей. Возможные значения, от менее стабильных к более стабильным: `dev`, `alpha`, `beta`, `RC`, `stable`. Значение `stable` — наиболее безопасный выбор для продакшн-проектов.

**`prefer-stable`** — даже если `minimum-stability` снижен до, например, `beta`, Composer при наличии возможности будет предпочитать стабильные версии пакетов.

### Задание 1.2. Добавление зависимости и её установка

Добавим в проект библиотеку **Carbon** — популярнейшую библиотеку для работы с датами и временем в PHP. Её создатель — Брайан Несбитт, имя пакета на Packagist — `nesbot/carbon`.

```bash
composer require nesbot/carbon
```

После выполнения команды произойдёт несколько вещей, и каждую из них полезно понимать.

**Во-первых**, Composer обновит `composer.json`, добавив запись о зависимости:

```json
"require": {
    "nesbot/carbon": "^2.72"
}
```

Символ `^` перед версией — это **оператор совместимости**. Он означает: «допускать любую версию, совместимую с указанной». Для версий с трёхчленной нумерацией (например, `2.72.3`) это значит: допускаются все версии от `2.72.0` до, но не включая `3.0.0`. Смена мажорной версии (первая цифра) по соглашению означает возможность *разрушающих изменений* в API — то есть функции могут измениться или исчезнуть. Поэтому Composer по умолчанию не переходит через границу мажорных версий.

Существуют и другие операторы ограничения версий:

| Оператор | Пример | Значение |
|---|---|---|
| `^` | `^2.3` | `>=2.3.0, <3.0.0` |
| `~` | `~2.3` | `>=2.3.0, <3.0.0` (аналогично `^` для двух цифр) |
| `~` | `~2.3.1` | `>=2.3.1, <2.4.0` (строже — фиксирует минорную версию) |
| `>=` | `>=2.0` | Любая версия 2.0 и выше |
| `==` | `==2.3.1` | Точно эта версия |

**Во-вторых**, появится файл `composer.lock`. Посмотрим на его часть:

```json
{
    "content-hash": "abc123...",
    "packages": [
        {
            "name": "nesbot/carbon",
            "version": "2.72.1",
            "source": {
                "type": "git",
                "url": "https://github.com/briannesbitt/Carbon.git",
                "reference": "a1234567..."
            },
            ...
        }
    ]
}
```

Здесь видна *точная* версия (`2.72.1`), а не диапазон. Отсюда и берётся детерминизм: когда любой другой разработчик запускает `composer install` в этом проекте, он получит *ту же самую* версию Carbon.

**В-третьих**, появится директория `vendor/`. В ней:

- `vendor/nesbot/carbon/` — исходный код библиотеки Carbon;
- `vendor/autoload.php` — файл автозагрузки, который нужно подключить в каждом PHP-файле для работы с установленными пакетами;
- прочие файлы, обеспечивающие работу автозагрузки.

> **Важно:** директорию `vendor/` **не** добавляйте в репозиторий Git. Создайте файл `.gitignore` в корне проекта с содержимым:
> ```
> vendor/
> ```
> Любой разработчик восстановит содержимое `vendor/` командой `composer install`.

### Задание 1.3. Использование установленной библиотеки

Создадим файл `index.php` в корне проекта:

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use Carbon\Carbon;

$now = Carbon::now();
echo "Текущая дата и время: " . $now->format('Y-m-d H:i:s') . PHP_EOL;

$nextWeek = Carbon::now()->addWeek();
echo "Через неделю будет: " . $nextWeek->format('l, F j, Y') . PHP_EOL;

$christmas = Carbon::parse('2025-12-25');
$daysUntil = Carbon::now()->diffInDays($christmas);
echo "До Рождества осталось: " . $daysUntil . " дней" . PHP_EOL;
```

Запустим скрипт:

```bash
php index.php
```

Обратите внимание на первую рабочую строку после открывающего тега:

```php
require_once __DIR__ . '/vendor/autoload.php';
```

Эта **единственная строка** подключает автозагрузчик Composer. После этого любой класс из любого пакета, установленного через Composer, будет загружен автоматически — без дополнительных `require` или `include`. Именно поэтому строка `use Carbon\Carbon;` работает без ошибок: Composer знает, где лежит файл с классом `Carbon\Carbon`, и загружает его в момент первого обращения.

Конструкция `__DIR__` — это магическая константа PHP, которая возвращает путь к директории, в которой лежит текущий файл. Это позволяет строить пути относительно файла, а не относительно текущей рабочей директории, что значительно надёжнее.

### Задание 1.4. Разница между `composer install` и `composer update`

Эти две команды часто путают, и понимать разницу между ними крайне важно.

**`composer install`** — устанавливает зависимости *точно* так, как они записаны в `composer.lock`. Если `composer.lock` существует, версии не меняются. Эта команда используется при клонировании проекта из репозитория или при деплое на сервер. Цель — воспроизвести точно ту среду, в которой работали другие члены команды.

**`composer update`** — обновляет зависимости до последних версий, допустимых ограничениями в `composer.json`, и перезаписывает `composer.lock`. Эта команда используется во время разработки, когда вы хотите получить актуальные версии библиотек.

Можно также обновить один конкретный пакет:

```bash
composer update nesbot/carbon
```

### Задание 1.5. Удаление зависимости

```bash
composer remove nesbot/carbon
```

Эта команда удалит пакет из `vendor/`, уберёт его запись из `composer.json` и обновит `composer.lock`. Вернём зависимость — она нам потребуется для демонстрации:

```bash
composer require nesbot/carbon
```

---

## Часть 2. Автозагрузка по стандарту PSR-4

### Задание 2.1. Создание структуры проекта

Создадим следующую структуру файлов:

```
composer-lab/
├── src/
│   ├── App/
│   │   ├── Models/
│   │   │   └── User.php
│   │   ├── Services/
│   │   │   └── GreeterService.php
│   │   └── App.php
│   └── Utils/
│       └── MathHelper.php
├── vendor/
├── composer.json
├── composer.lock
└── index.php
```

Каждый файл содержит один класс с пространством имён, соответствующим его положению в каталогах. Это и есть суть стандарта PSR-4: один файл — один класс, и путь к файлу точно отражает пространство имён.

### Задание 2.2. Создание классов

Создадим файл `src/App/Models/User.php`:

```php
<?php

namespace App\Models;

class User
{
    public function __construct(
        private string $name,
        private string $email,
        private int $age
    ) {}

    public function getName(): string
    {
        return $this->name;
    }

    public function getEmail(): string
    {
        return $this->email;
    }

    public function getAge(): int
    {
        return $this->age;
    }

    public function getInfo(): string
    {
        return "{$this->name} ({$this->email}), возраст: {$this->age}";
    }
}
```

Остановимся на нескольких моментах в этом коде.

**Пространство имён.** Строка `namespace App\Models;` объявляет, что класс `User` принадлежит пространству имён `App\Models`. Его полное имя — `App\Models\User`. Обратите внимание: это полное имя *должно* совпадать с путём к файлу относительно базовой директории, которую мы укажем в `composer.json`. Если базовая директория для `App\` — это `src/App/`, то `App\Models\User` должен находиться в `src/App/Models/User.php`. Мы именно так и расположили файл.

**Promoted properties (продвинутые свойства).** Конструктор использует возможность PHP 8.0: когда параметр конструктора объявлен с модификатором видимости (`private`, `protected` или `public`), PHP автоматически создаёт свойство класса с таким же именем и присваивает ему значение аргумента. Без этой возможности код выглядел бы так:

```php
// Без promoted properties — больше кода, то же функционально
private string $name;
private string $email;
private int $age;

public function __construct(string $name, string $email, int $age)
{
    $this->name = $name;
    $this->email = $email;
    $this->age = $age;
}
```

С promoted properties весь этот код заменяется тремя строками в сигнатуре конструктора.

Создадим файл `src/App/Services/GreeterService.php`:

```php
<?php

namespace App\Services;

use App\Models\User;

class GreeterService
{
    private array $greetings = [];

    public function greet(User $user): string
    {
        $message = "Привет, {$user->getName()}! Добро пожаловать.";
        $this->greetings[] = $message;

        return $message;
    }

    public function getGreetingCount(): int
    {
        return count($this->greetings);
    }

    public function getAllGreetings(): array
    {
        return $this->greetings;
    }
}
```

Этот класс демонстрирует использование одного класса внутри другого через пространства имён. Строка `use App\Models\User;` импортирует класс `User`. После этого в сигнатуре метода `greet` мы указываем просто `User`, а не его полное имя `\App\Models\User`. Это называется *импортом* и работает аналогично тому, как `import` работает в Python или Java.

Без оператора `use` пришлось бы писать полное имя каждый раз:

```php
public function greet(\App\Models\User $user): string
```

Это существенно снижает читаемость, особенно в большом проекте с глубокой структурой пространств имён.

Создадим файл `src/Utils/MathHelper.php`:

```php
<?php

namespace Utils;

class MathHelper
{
    public static function factorial(int $n): int
    {
        if ($n < 0) {
            throw new \InvalidArgumentException(
                "Факториал не определён для отрицательных чисел."
            );
        }

        if ($n <= 1) {
            return 1;
        }

        return $n * self::factorial($n - 1);
    }

    public static function isPrime(int $n): bool
    {
        if ($n < 2) {
            return false;
        }

        for ($i = 2; $i <= (int)sqrt($n); $i++) {
            if ($n % $i === 0) {
                return false;
            }
        }

        return true;
    }

    public static function fibonacci(int $count): array
    {
        if ($count <= 0) {
            return [];
        }

        $sequence = [0];

        if ($count === 1) {
            return $sequence;
        }

        $sequence[] = 1;

        for ($i = 2; $i < $count; $i++) {
            $sequence[] = $sequence[$i - 1] + $sequence[$i - 2];
        }

        return $sequence;
    }
}
```

Два важных момента в этом файле. Первый: пространство имён — просто `Utils`, без префикса `App`. Это абсолютно нормально. Пространства имён — инструмент организации кода, и вы свободны называть их как угодно. Единственное ограничение — соответствие структуре каталогов, заданное PSR-4. Поскольку файл лежит в `src/Utils/`, пространство имён — `Utils`.

Второй момент: в строке `throw new \InvalidArgumentException(...)` перед именем класса стоит обратный слэш (`\`). Это означает «искать класс в глобальном пространстве имён». Без этого слэша PHP стал бы искать `Utils\InvalidArgumentException`, что не существует, и выбросил бы ошибку. Когда вы находитесь внутри какого-либо пространства имён и хотите использовать встроенный PHP-класс (например, исключение из стандартной библиотеки), перед его именем необходимо поставить `\`. Альтернатива — импортировать его через `use`:

```php
use InvalidArgumentException;

// Теперь можно использовать без слеша:
throw new InvalidArgumentException("...");
```

Наконец, создадим файл `src/App/App.php`:

```php
<?php

namespace App;

use App\Models\User;
use App\Services\GreeterService;
use Utils\MathHelper;

class App
{
    private GreeterService $greeter;

    public function __construct()
    {
        $this->greeter = new GreeterService();
    }

    public function run(): void
    {
        echo "=== Приложение запущено ===" . PHP_EOL . PHP_EOL;

        $users = [
            new User('Анна', 'anna@example.com', 22),
            new User('Борис', 'boris@example.com', 25),
            new User('Вера', 'vera@example.com', 20),
        ];

        echo "--- Приветствия ---" . PHP_EOL;
        foreach ($users as $user) {
            echo $this->greeter->greet($user) . PHP_EOL;
        }
        echo "Всего приветствий: " . $this->greeter->getGreetingCount() . PHP_EOL . PHP_EOL;

        echo "--- Информация о пользователях ---" . PHP_EOL;
        foreach ($users as $user) {
            echo $user->getInfo() . PHP_EOL;
        }
        echo PHP_EOL;

        echo "--- Математика ---" . PHP_EOL;
        echo "5! = " . MathHelper::factorial(5) . PHP_EOL;
        echo "10! = " . MathHelper::factorial(10) . PHP_EOL . PHP_EOL;

        echo "Простые числа до 30: ";
        $primes = [];
        for ($i = 2; $i <= 30; $i++) {
            if (MathHelper::isPrime($i)) {
                $primes[] = $i;
            }
        }
        echo implode(', ', $primes) . PHP_EOL . PHP_EOL;

        $fibCount = 10;
        $fibonacci = MathHelper::fibonacci($fibCount);
        echo "Первые {$fibCount} чисел Фибоначчи: " . implode(', ', $fibonacci) . PHP_EOL;

        echo PHP_EOL . "--- Работа с датами (Carbon) ---" . PHP_EOL;
        $now = \Carbon\Carbon::now();
        echo "Текущая дата: " . $now->format('Y-m-d') . PHP_EOL;
        echo "Через месяц: " . $now->addMonth()->format('Y-m-d') . PHP_EOL;
    }
}
```

Этот класс служит главной точкой входа приложения и собирает всё вместе. Заметьте, что ни в одном месте нет `require` или `include` для наших собственных классов — только `use` для импорта. Всё остальное берёт на себя автозагрузка. Также обратите внимание, что Carbon используется здесь через полное имя `\Carbon\Carbon` — мы могли бы и импортировать его через `use Carbon\Carbon;` наверху файла, но это просто альтернативный способ, демонстрирующий, что оба варианта работают.

### Задание 2.3. Настройка автозагрузки в composer.json

Теперь — ключевой этап. Нужно сообщить Composer, где находятся наши классы. Добавим раздел `autoload` в `composer.json`:

```json
{
    "name": "student/composer-lab",
    "description": "Лабораторная работа по Composer",
    "type": "project",
    "require": {
        "nesbot/carbon": "^2.72"
    },
    "authors": [
        {
            "name": "Ваше имя",
            "email": "ваша@почта.com"
        }
    ],
    "autoload": {
        "psr-4": {
            "App\\": "src/App/",
            "Utils\\": "src/Utils/"
        }
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}
```

Разберём раздел `autoload` подробно, потому что это сердце всей автозагрузки.

Внутри `autoload` указан стандарт — `psr-4`. Далее объект, в котором каждая пара «ключ — значение» — это *маппинг* (соответствие) между пространством имён и директорией:

**`"App\\" → "src/App/"`** — правило: если понадобится класс из пространства имён, начинающегося с `App\`, искать его в директории `src/App/`, сохраняя остальную часть пути. Пример работы этого правила:

| Полное имя класса | Убираем префикс `App\` | Заменяем `\` на `/` | Добавляем базовую директорию | Итоговый путь |
|---|---|---|---|---|
| `App\Models\User` | `Models\User` | `Models/User` | `src/App/` | `src/App/Models/User.php` |
| `App\Services\GreeterService` | `Services\GreeterService` | `Services/GreeterService` | `src/App/` | `src/App/Services/GreeterService.php` |
| `App\App` | `App` | `App` | `src/App/` | `src/App/App.php` |

**`"Utils\\" → "src/Utils/"`** — аналогичное правило для пространства имён `Utils`:

| Полное имя класса | Итоговый путь |
|---|---|
| `Utils\MathHelper` | `src/Utils/MathHelper.php` |

> **Почему двойной слэш?** В JSON обратный слэш (`\`) — это символ экранирования. Чтобы представить один буквальный `\`, нужно написать два: `\\`. Поэтому ключ `"App\\"` в JSON — это строка `App\` в действительности. Это не особенность PHP или Composer — это стандартный JSON.

После изменения `composer.json` необходимо обновить автозагрузчик:

```bash
composer dump-autoload
```

Эта команда перегенерирует файлы автозагрузки в директории `vendor/`. Её необходимо запускать **каждый раз**, когда вы изменяете раздел `autoload` в `composer.json`. Без этого шага Composer просто не знает о новых правилах, и попытка использовать ваши классы приведёт к ошибке «класс не найден».

### Задание 2.4. Обновление точки входа и запуск

Обновим `index.php`:

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use App\App;

$app = new App();
$app->run();
```

Заметьте, как упростилась точка входа: всего три строки полезного кода. Запускаем:

```bash
php index.php
```

Ожидаемый вывод:

```
=== Приложение запущено ===

--- Приветствия ---
Привет, Анна! Добро пожаловать.
Привет, Борис! Добро пожаловать.
Привет, Вера! Добро пожаловать.
Всего приветствий: 3

--- Информация о пользователях ---
Анна (anna@example.com), возраст: 22
Борис (boris@example.com), возраст: 25
Вера (vera@example.com), возраст: 20

--- Математика ---
5! = 120
10! = 3628800

Простые числа до 30: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29

Первые 10 чисел Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34

--- Работа с датами (Carbon) ---
Текущая дата: 2026-01-31
Через месяц: 2026-02-28
```

Если вывод совпадает с ожидаемым — автозагрузка работает корректно. Каждый класс загружен автоматически из своего файла, и при этом в коде нет ни одного `require` для наших собственных классов.

### Задание 2.5. Распространённая ошибка и как её диагностировать

Попробуем специально вызвать ошибку автозагрузки для того, чтобы понять, как её исправлять в дальнейшей работе. Создадим файл `src/App/Models/BrokenModel.php`:

```php
<?php

namespace App\Models;

class BrokenModelWrongName  // Имя класса не совпадает с именем файла
{
    public function hello(): string
    {
        return "Hello from BrokenModel!";
    }
}
```

Обратите внимание: файл называется `BrokenModel.php`, но класс внутри — `BrokenModelWrongName`. Попробуем использовать этот класс в `index.php`:

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use App\Models\BrokenModel;

$obj = new BrokenModel();
echo $obj->hello();
```

```bash
php index.php
```

PHP выдаст ошибку: *Class "App\Models\BrokenModel" not found*. Причина — автозагрузчик ищет класс `BrokenModel` в файле `src/App/Models/BrokenModel.php`, открывает файл, но внутри не находит класс с таким именем (там `BrokenModelWrongName`). Это наиболее распространённая ошибка при работе с PSR-4: **имя файла должно точно совпадать с именем класса**, с учётом регистра букв.

Исправим ошибку — удалим тестовый файл и вернём `index.php` к предыдущему состоянию:

```bash
rm src/App/Models/BrokenModel.php
```

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use App\App;

$app = new App();
$app->run();
```

---

## Часть 3. Контрольные задания

Выполните следующие задания самостоятельно. Все файлы должны быть расположены в той же структуре каталогов проекта.

### Задание 3.1

Создайте класс `App\Models\Product` в файле `src/App/Models/Product.php` со следующими полями: `name` (string), `price` (float), `quantity` (int). Реализуйте метод `getTotalValue(): float`, который возвращает произведение цены на количество. Также реализуйте метод `__toString(): string`, который возвращает строку в формате: `Product: {name}, Цена: {price}, Кол-во: {quantity}`.

### Задание 3.2

Создайте класс `App\Services\CartService` в файле `src/App/Services/CartService.php`. Этот класс должен хранить массив объектов `Product` и предоставлять методы: `addProduct(Product $product): void` — для добавления товара в корзину, `getTotalCost(): float` — для подсчёта общей стоимости всех товаров, `getProductCount(): int` — для получения количества товаров в корзине.

### Задание 3.3

Добавьте в `index.php` блок кода, который создаёт несколько объектов `Product`, добавляет их в `CartService` и выводит итоговую стоимость корзины и количество товаров. Каждый товар должен быть также выведен через `__toString()`.

### Задание 3.4

Добавьте в `composer.json` зависимость `monolog/monolog` (библиотека для логирования) и установите её через Composer. Создайте в корне проекта файл `logger.php`, который подключает автозагрузчик, создаёт экземпляр логгера Monolog с обработчиком `StreamHandler` для записи в файл `app.log`, записывает сообщение информационного уровня (`info`) и сообщение уровня ошибки (`error`), а затем выводит содержимое файла `app.log` в терминал с помощью `file_get_contents()`.

---

## Часть 4. Итоговая проверка и структура проекта

После выполнения всех заданий ваш проект должен иметь следующую структуру:

```
composer-lab/
├── src/
│   ├── App/
│   │   ├── Models/
│   │   │   ├── User.php
│   │   │   └── Product.php          ← задание 3.1
│   │   ├── Services/
│   │   │   ├── GreeterService.php
│   │   │   └── CartService.php      ← задание 3.2
│   │   └── App.php
│   └── Utils/
│       └── MathHelper.php
├── vendor/
├── .gitignore
├── composer.json
├── composer.lock
├── index.php                         ← обновлён в задании 3.3
└── logger.php                        ← задание 3.4
```

Убедитесь, что:

1. Файл `.gitignore` существует и содержит строку `vendor/`;
2. В `composer.json` прописаны обе зависимости: `nesbot/carbon` и `monolog/monolog`;
3. В разделе `autoload` прописаны маппинги для `App\` и `Utils\`;
4. Все классы в файлах `src/` содержат корректные объявления пространств имён;
5. `php index.php` и `php logger.php` запускаются без ошибок.

### Итоговый `composer.json`

После выполнения всех заданий ваш `composer.json` должен выглядеть примерно так (версии пакетов могут отличаться):

```json
{
    "name": "student/composer-lab",
    "description": "Лабораторная работа по Composer",
    "type": "project",
    "require": {
        "nesbot/carbon": "^2.72",
        "monolog/monolog": "^3.6"
    },
    "authors": [
        {
            "name": "Ваше имя",
            "email": "ваша@почта.com"
        }
    ],
    "autoload": {
        "psr-4": {
            "App\\": "src/App/",
            "Utils\\": "src/Utils/"
        }
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}
```

### Полезные команды Composer — справочник

| Команда | Описание |
|---|---|
| `composer init` | Интерактивная инициализация нового проекта |
| `composer require vendor/package` | Добавить зависимость и установить её |
| `composer install` | Установить зависимости из `composer.lock` |
| `composer update` | Обновить все зависимости до последних версий |
| `composer update vendor/package` | Обновить конкретный пакет |
| `composer remove vendor/package` | Удалить зависимость |
| `composer dump-autoload` | Перегенерировать файлы автозагрузки |
| `composer show` | Показать список установленных пакетов |
| `composer outdated` | Показать устаревшие пакеты |
| `composer why vendor/package` | Показать, почему пакет установлен (кто его требует) |

---

## Контрольные вопросы

1. Что такое файл `composer.lock` и почему его необходимо хранить в репозитории Git?
2. Объясните разницу между командами `composer install` и `composer update`. В каких ситуациях используется каждая из них?
3. Почему в `composer.json` после имени пространства имён пишут двойной обратный слэш (`\\`), а не один?
4. Что происходит, если вы изменили раздел `autoload` в `composer.json`, но забыли запустить `composer dump-autoload`?
5. Объясните, почему перед стандартными классами PHP (например, `InvalidArgumentException`) в коде, расположенном внутри пространства имён, необходимо ставить обратный слэш (`\`). Назовите альтернативный способ решения этой задачи.
6. Почему имя файла должно точно совпадать с именем класса при использовании автозагрузки PSR-4?

Ответы на контрольные вопросы нужно оформить в отдельном файле `answers.txt` в корне проекта.

---

## Итог

В ходе лабораторной работы была полностью освоена инфраструктура управления зависимостями PHP. Было показано, как создать проект с использованием Composer, устанавливать внешние библиотеки и пользоваться ими, организовывать собственный код в пространства имён и настраивать автозагрузку по стандарту PSR-4. Была рассмотрена типичная ошибка несовпадения имени файла и имени класса, а также способ её диагностики. Полученные навыки являются базовыми для работы с любым современным PHP-проектом, включая Laravel, который целиком построен на Composer и PSR-4.