# Лабораторная работа №2: Namespaces и использование стандартов PSR

## Информация о работе

| Параметр | Значение |
|---|---|
| Тема | Пространства имён и стандарты кодирования PSR |
| Зависимости | PHP ^8.3, Composer, проект из лабораторной работы №1 |
| Стандарты | PSR-1, PSR-12, PSR-4 |
| Предварительное условие | Лабораторная работа №1 должна быть выполнена |

---

## Цели работы

Данная лабораторная работа представляет собой продолжение работы с проектом из лабораторной работы №1. В первой части будет углублённо рассмотрена тема пространств имён: будут изучены вложенные пространства имён, механизмы их импорта, псевдонимы классов и разрешение конфликтов имён. Во второй части будут изучены стандарты кодирования PSR-1 и PSR-12, а в проект будет интегрирован инструмент автоматической проверки кода на соответствие этим стандартам.

---

## Теоретическая справка

### Быстрый повтор: пространства имён

В лабораторной работе №1 мы создавали классы с пространствами имён и использовали оператор `use` для их импорта. Напомним ключевое правило: пространство имён объявляется в начале файла через ключевое слово `namespace`, а для использования класса из другого пространства в текущем файле применяется оператор `use`.

В этой лабораторной работе мы расширим понимание пространств имён, рассмотрим сценарии, которые часто встречаются в реальных проектах, и разберём ситуации, в которых начинающие разработчики чаще всего ошибаются.

### Что такие стандарты PSR?

**PSR** (PHP Standards Recommendation) — это набор рекомендаций по написанию PHP-кода, разработанных организацией **PHP-FIG** (PHP Framework Interop Group). Эти стандарты не являются обязательными с точки зрения языка — PHP запустит любой код, написанный как угодно. Однако стандарты существенно влияют на то, как легко другие люди читают и поддерживают ваш код.

Особенно это важно в командной работе и в экосистеме с совместно используемыми библиотеками. Если каждый разработчик пишет код по-своему, изучение чужого кода превращается в бесконечный процесс адаптации. Единый стандарт снимает эту проблему.

В этой работе мы разберём два стандарта:

- **PSR-1** — базовый стандарт кодирования. Задаёт фундаментальные правила: кодировку файлов, правила именования классов, констант и методов, использование тегов PHP.
- **PSR-12** — расширенный стандарт кодирования. Задаёт правила оформления кода: отступы, скобки, пробелы, длину строк и многое другое. PSR-12 является преемником устаревшего PSR-2 и полностью его заменяет.

---

## Часть 1. Углублённое изучение пространств имён

Продолжаем работу с проектом `composer-lab`, созданным в лабораторной работе №1. Убедитесь, что проект существует и запускается корректно:

```bash
cd composer-lab
php index.php
```

### Задание 1.1. Вложенные пространства имён и их организация

В лабораторной работе №1 мы использовали пространства имён в их простейшей форме: `App\Models`, `App\Services`, `Utils`. Теперь рассмотрим более глубокую вложенность, которая является нормой в реальных проектах.

Представим, что наше приложение растёт, и появляется необходимость работать с исключениями. В крупных проектах исключения выделяются в отдельное пространство имён, чтобы их было легко найти и чтобы они не засоряли другие пространства. Создадим файл `src/App/Exceptions/ValidationException.php`:

```php
<?php

namespace App\Exceptions;

class ValidationException extends \RuntimeException
{
    private array $errors;

    public function __construct(array $errors, int $code = 0, ?\Throwable $previous = null)
    {
        $this->errors = $errors;
        $message = "Ошибка валидации: " . implode(', ', $errors);

        parent::__construct($message, $code, $previous);
    }

    public function getErrors(): array
    {
        return $this->errors;
    }
}
```

Здесь несколько важных деталей. Класс `ValidationException` расширяет встроенный `\RuntimeException`. Обратите внимание на ведущий обратный слэш — без него PHP искал бы `App\Exceptions\RuntimeException`, что не существует. Аналогично для типа `?\Throwable` в параметре `$previous`: это нулеваемый тип (значение может быть `null`), и интерфейс `Throwable` также относится к глобальному пространству имён.

Давайте подробно разберём, как PHP разрешает имя класса, когда вы его используете. Это понимание существенно помогает при отладке ошибок типа «класс не найден».

Когда PHP видит имя класса в коде, он поступает так:

1. Если имя начинается с `\` (например, `\RuntimeException`) — это **абсолютное** имя. PHP ищет класс в глобальном пространстве имён. Точка. Никакие дополнительные поиски не ведутся.

2. Если имя **импортировано** через `use` (например, мы написали `use App\Models\User;` наверху файла) — PHP подставляет полное имя, указанное в `use`. То есть `User` в теле кода превращается в `App\Models\User`.

3. Если имя **не импортировано** и не начинается с `\` (например, просто `RuntimeException` внутри файла с `namespace App\Exceptions;`) — PHP **сначала** ищет `App\Exceptions\RuntimeException`. Если не находит — **не ищет** в глобальном пространстве имён. Он просто выбрасывает ошибку «класс не найден». Именно поэтому перед встроенными классами PHP обязателен обратный слэш, когда вы находитесь внутри любого пространства имён.

Эта тройка правил — всё, что нужно знать для правильной работы с пространствами имён. Если вы всегда помните их, ошибки «класс не найден» перестают быть загадкой.

Теперь создадим класс, который использует это исключение. Создадим файл `src/App/Services/UserValidator.php`:

```php
<?php

namespace App\Services;

use App\Exceptions\ValidationException;
use App\Models\User;

class UserValidator
{
    public static function validate(string $name, string $email, int $age): User
    {
        $errors = [];

        if (strlen($name) < 2) {
            $errors[] = "Имя должно содержать не менее 2 символов";
        }

        if (!str_contains($email, '@')) {
            $errors[] = "Некорректный адрес электронной почты";
        }

        if ($age < 0 || $age > 150) {
            $errors[] = "Возраст должен быть от 0 до 150";
        }

        if (!empty($errors)) {
            throw new ValidationException($errors);
        }

        return new User($name, $email, $age);
    }
}
```

Обратите внимание, как коротко и чисто выглядят импорты наверху файла: `use App\Exceptions\ValidationException;` и `use App\Models\User;`. Далее в теле класса мы используем только короткие имена. Это и есть цель механизма `use` — убрать длинные полные имена из рабочего кода и сосредоточить их в одном месте, наверху файла.

Добавим демонстрацию валидатора в класс `App`. Откроем `src/App/App.php` и добавим импорт и блок кода:

```php
<?php

namespace App;

use App\Exceptions\ValidationException;
use App\Models\User;
use App\Services\GreeterService;
use App\Services\UserValidator;
use Utils\MathHelper;

class App
{
    private GreeterService $greeter;

    public function __construct()
    {
        $this->greeter = new GreeterService();
    }

    public function run(): void
    {
        echo "=== Приложение запущено ===" . PHP_EOL . PHP_EOL;

        // --- Валидация пользователей ---
        echo "--- Валидация пользователей ---" . PHP_EOL;
        $testCases = [
            ['Анна', 'anna@example.com', 22],
            ['', 'boris@example.com', 25],          // пустое имя
            ['Вера', 'vera-invalid-email', 20],     // некорректная почта
            ['Да', 'da@ok.com', -5],                // отрицательный возраст
        ];

        foreach ($testCases as [$name, $email, $age]) {
            try {
                $user = UserValidator::validate($name, $email, $age);
                echo "OK: " . $user->getInfo() . PHP_EOL;
            } catch (ValidationException $e) {
                echo "ОШИБКА: " . $e->getMessage() . PHP_EOL;
            }
        }
        echo PHP_EOL;

        // --- Приветствия ---
        echo "--- Приветствия ---" . PHP_EOL;
        $users = [
            new User('Анна', 'anna@example.com', 22),
            new User('Борис', 'boris@example.com', 25),
        ];

        foreach ($users as $user) {
            echo $this->greeter->greet($user) . PHP_EOL;
        }
        echo PHP_EOL;

        // --- Математика ---
        echo "--- Математика ---" . PHP_EOL;
        echo "5! = " . MathHelper::factorial(5) . PHP_EOL;

        $primes = [];
        for ($i = 2; $i <= 30; $i++) {
            if (MathHelper::isPrime($i)) {
                $primes[] = $i;
            }
        }
        echo "Простые числа до 30: " . implode(', ', $primes) . PHP_EOL;
    }
}
```

Запускаем и проверяем результат:

```bash
php index.php
```

```
=== Приложение запущено ===

--- Валидация пользователей ---
OK: Анна (anna@example.com), возраст: 22
ОШИБКА: Ошибка валидации: Имя должно содержать не менее 2 символов
ОШИБКА: Ошибка валидации: Некорректный адрес электронной почты
ОШИБКА: Ошибка валидации: Возраст должен быть от 0 до 150

--- Приветствия ---
Привет, Анна! Добро пожаловать.
Привет, Борис! Добро пожаловать.

--- Математика ---
5! = 120
Простые числа до 30: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29
```

### Задание 1.2. Псевдонимы классов (use ... as)

Бывают ситуации, когда в одном файле необходимо использовать два класса с одинаковым именем из разных пространств имён. Например, в вашем проекте есть `App\Models\User`, и вы подключаете внешнюю библиотеку, в которой тоже есть класс `User`. Без каких-либо дополнительных мер PHP не сможет определить, какой именно `User` имеется в виду.

Для таких случаев существует механизм **псевдонимов** — оператор `as`. Он позволяет присвоить импортируемому классу любое другое имя в пределах текущего файла.

Создадим демонстрацию. Для этого добавим в проект пространство имён, имитирующее внешнюю библиотеку. Создадим файл `src/App/External/User.php`:

```php
<?php

namespace App\External;

/**
 * Имитация класса User из некоторой внешней библиотеки.
 * В реальном проекте этот класс был бы из vendor/.
 */
class User
{
    public function __construct(
        private string $username,
        private string $token
    ) {}

    public function getUsername(): string
    {
        return $this->username;
    }

    public function getToken(): string
    {
        return $this->token;
    }
}
```

Теперь создадим файл, который использует оба класса — наш `App\Models\User` и «внешний» `App\External\User`. Создадим `src/App/Services/AuthService.php`:

```php
<?php

namespace App\Services;

use App\Models\User;
use App\External\User as ExternalUser;

class AuthService
{
    /**
     * Принимает объект нашего User и возвращает объект «внешнего» User,
     * имитируя процесс аутентификации через внешний сервис.
     */
    public function authenticate(User $user): ExternalUser
    {
        // Имитация генерации токена
        $token = base64_encode($user->getEmail() . ':' . time());

        return new ExternalUser($user->getName(), $token);
    }
}
```

Обратите внимание на строку импорта:

```php
use App\External\User as ExternalUser;
```

После этой строки класс `App\External\User` доступен в файле под именем `ExternalUser`. А наш собственный `App\Models\User` импортирован без псевдонима и доступен под обычным именем `User`. Конфликт полностью разрешён, код читается легко.

### Задание 1.3. Группировка импортов (grouped use)

Когда из одного пространства имён нужно импортировать несколько классов, их можно объединить в один оператор `use` с помощью фигурных скобок. Это функция, появившаяся в PHP 7.

Рассмотрим, как это выглядело бы без группировки:

```php
use App\Models\User;
use App\Models\Product;
use App\Models\Order;
use App\Services\UserValidator;
use App\Services\AuthService;
use App\Services\CartService;
```

С группировкой:

```php
use App\Models\{User, Product, Order};
use App\Services\{UserValidator, AuthService, CartService};
```

Результат абсолютно тот же: все шесть классов импортированы и доступны по коротким именам. Разница только в записи. Grouped use — это удобство для глаз, ничего больше. Оба варианта полностью эквивалентны с точки зрения работы PHP.

Показать эквивалентность можно в виде таблицы — для каждого класса результат разрешения одинаков:

| Полное имя | Без группировки | С группировкой | Доступно в коде как |
|---|---|---|---|
| `App\Models\User` | `use App\Models\User;` | `use App\Models\{User, ...};` | `User` |
| `App\Models\Product` | `use App\Models\Product;` | `use App\Models\{..., Product, ...};` | `Product` |
| `App\Services\AuthService` | `use App\Services\AuthService;` | `use App\Services\{AuthService, ...};` | `AuthService` |

> **Когда не использовать группировку.** Если в одной группе получается слишком много классов (больше 3–4), читаемость снижается. В таких случаях лучше оставить отдельные строки `use`. Также Laravel и большинство крупных проектов предпочитают отдельные строки — это проще для инструментов автоформатирования и для `git diff` (каждое изменение импорта видно как отдельная строка).

Обновим `src/App/App.php`, используя группировку:

```php
<?php

namespace App;

use App\Exceptions\ValidationException;
use App\Models\User;
use App\Services\{AuthService, GreeterService, UserValidator};
use Utils\MathHelper;

class App
{
    private GreeterService $greeter;
    private AuthService $auth;

    public function __construct()
    {
        $this->greeter = new GreeterService();
        $this->auth = new AuthService();
    }

    public function run(): void
    {
        echo "=== Приложение запущено ===" . PHP_EOL . PHP_EOL;

        // --- Валидация и аутентификация ---
        echo "--- Валидация и аутентификация ---" . PHP_EOL;

        try {
            $user = UserValidator::validate('Анна', 'anna@example.com', 22);
            echo "Валидация: OK — " . $user->getInfo() . PHP_EOL;

            $externalUser = $this->auth->authenticate($user);
            echo "Аутентификация: OK — пользователь «" . $externalUser->getUsername() . "»" . PHP_EOL;
            echo "Токен: " . $externalUser->getToken() . PHP_EOL;
        } catch (ValidationException $e) {
            echo "ОШИБКА: " . $e->getMessage() . PHP_EOL;
        }

        echo PHP_EOL;

        // --- Приветствия ---
        echo "--- Приветствия ---" . PHP_EOL;
        $users = [
            new User('Анна', 'anna@example.com', 22),
            new User('Борис', 'boris@example.com', 25),
        ];

        foreach ($users as $user) {
            echo $this->greeter->greet($user) . PHP_EOL;
        }
        echo PHP_EOL;

        // --- Математика ---
        echo "--- Математика ---" . PHP_EOL;
        echo "5! = " . MathHelper::factorial(5) . PHP_EOL;

        $fibonacci = MathHelper::fibonacci(10);
        echo "Числа Фибоначчи: " . implode(', ', $fibonacci) . PHP_EOL;
    }
}
```

```bash
php index.php
```

### Задание 1.4. Функции и констант в пространствах имён

Пространства имён распространяются не только на классы, но и на функции и константы. Это менее известная, но полезная особенность. Создадим файл `src/Utils/StringHelpers.php`, содержащий функции (а не класс):

```php
<?php

namespace Utils;

/**
 * Функция для преобразования строки в формат «Title Case»:
 * первая буква каждого слова — заглавная.
 */
function titleCase(string $text): string
{
    return ucwords(strtolower($text));
}

/**
 * Функция для обрезки строки до указанной длины
 * с добавлением «...» в конце, если строка была обрезана.
 */
function truncate(string $text, int $maxLength = 30): string
{
    if (mb_strlen($text) <= $maxLength) {
        return $text;
    }

    return mb_substr($text, 0, $maxLength - 3) . '...';
}

/**
 * Константа в пространстве имён.
 */
const APP_VERSION = '1.0.0';
```

Для использования этих функций и константы необходимо их импортировать явно. Для функций применяется синтаксис `use function`, для констант — `use const`:

```php
use function Utils\titleCase;
use function Utils\truncate;
use const Utils\APP_VERSION;
```

Добавим демонстрацию в `index.php`:

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use App\App;
use function Utils\titleCase;
use function Utils\truncate;
use const Utils\APP_VERSION;

$app = new App();
$app->run();

echo PHP_EOL . "--- Вспомогательные функции ---" . PHP_EOL;
echo "Версия приложения: " . APP_VERSION . PHP_EOL;
echo "titleCase: " . titleCase('здравствуйте мир') . PHP_EOL;
echo "truncate: " . truncate('Это очень длинная строка, которая должна быть обрезана', 25) . PHP_EOL;
```

```bash
php index.php
```

> **Примечание.** Функции из пространств имён — это полезная инструментация, однако в реальных проектах большинство разработчиков предпочитают оборачивать утилитарные функции в статические методы классов. Причина — статические методы автоматически загружаются через PSR-4, тогда как функции из пространств имён требуют ручного подключения через `use function` или явного указания полного имени. Функции в пространствах имён полезны для небольших утилит и для понимания механизма, но в крупных проектах предпочитаемый подход — класс со статическими методами.

---

## Часть 2. Стандарты кодирования: PSR-1 и PSR-12

### Теоретический обзор PSR-1

PSR-1 устанавливает минимально необходимый набор правил, на которых основаны все остальные стандарты. Перечислим их:

**1. Кодировка файлов.** Все PHP-файлы должны использовать кодировку UTF-8 без BOM (Byte Order Mark). BOM — это невидимый символ в начале файла, который некоторые текстовые редакторы добавляют автоматически. Его наличие может вызывать проблемы при обработке файлов PHP.

**2. Открывающие и закрывающие теги.** PHP-файлы, содержащие только PHP-код (без HTML), должны использовать только открывающий тег `<?php` без закрывающего тега `?>`. Причина — если после закрывающего тега есть пробел или перевод строки, они будут отправлены в output как часть HTML, что может вызвать невидимые ошибки с HTTP-заголовками.

**3. Объявления.** Файлы должны содержать либо объявления (классы, функции, констант), либо побочный код (вывод HTML, инициализация), но не то и другое одновременно.

**4. Пространства имён и `use`.** Пространства имён и операторы `use` должны соответствовать автозагрузчику PSR-4 (что мы уже делаем).

**5. Именование классов.** Имена классов должны быть записаны в формате `PascalCase` (каждое слово начинается с заглавной буквы, пробелов нет): `UserValidator`, `CartService`, `ValidationException`.

**6. Именование констант классов.** Константы внутри классов должны быть записаны целиком заглавными буквами через подчёркивание: `MAX_ATTEMPTS`, `DEFAULT_TIMEOUT`.

**7. Именование методов.** Имена методов должны быть записаны в формате `camelCase` (первое слово строчными, каждое следующее — с заглавной): `getUser`, `validateEmail`, `calculateTotal`.

### Теоретический обзор PSR-12

PSR-12 расширяет PSR-1 и задаёт подробные правила оформления кода. Перечислим наиболее часто нарушаемые правила:

**1. Отступы.** Для отступов используются только пробелы, не табуляции. Размер отступа — 4 пробела на уровень вложенности.

**2. Длина строк.** Строки должны быть ограничены до 120 символов (мягкое ограничение). Некоторые проекты используют 79 символов — это более строгий вариант.

**3. Открывающая фигурная скобка класса и метода.** Должна стоять на следующей строке после объявления (стиль Allman):

```php
// ✓ Правильно
class User
{
    public function getName(): string
    {
        return $this->name;
    }
}

// ✗ Неправильно — скобка на той же строке
class User {
    public function getName(): string {
        return $this->name;
    }
}
```

**4. Открывающая скобка условных конструкций и циклов.** Должна стоять на той же строке, что и ключевое слово:

```php
// ✓ Правильно
if ($condition) {
    // ...
}

for ($i = 0; $i < 10; $i++) {
    // ...
}

// ✗ Неправильно
if ($condition)
{
    // ...
}
```

**5. Модификаторы видимости.** Должны указываться явно для каждого свойства и метода. Не оставляйте видимость по умолчанию:

```php
// ✓ Правильно
public function getName(): string { ... }
private string $name;

// ✗ Неправильно — видимость не указана
function getName(): string { ... }
```

**6. Пробелы в аргументах.** После запятой между аргументами — один пробел. Пробелов перед запятой нет:

```php
// ✓ Правильно
public function __construct(string $name, int $age, string $email) {}

// ✗ Неправильно
public function __construct(string $name , int $age,string $email) {}
```

### Справочник: PSR-1 и PSR-12 — полный набор правил

Ниже собрана сводная таблица всех ключевых правил обоих стандартов. Обращайтесь к ней во время выполнения заданий.

| № | Стандарт | Правило | Пример |
|---|---|---|---|
| 1 | PSR-1 | Кодировка файлов — UTF-8 без BOM | — |
| 2 | PSR-1 | Файлы с чистым PHP не содержат закрывающий тег `?>` | Файл заканчивается после последней строки кода |
| 3 | PSR-1 | Имена классов — `PascalCase` | `UserValidator`, `CartService` |
| 4 | PSR-1 | Константы классов — `UPPER_SNAKE_CASE` | `MAX_RETRIES`, `DEFAULT_STATUS` |
| 5 | PSR-1 | Имена методов — `camelCase` | `findById`, `calculateTotal` |
| 6 | PSR-12 | Отступы — 4 пробела, не табуляции | `····public function` |
| 7 | PSR-12 | Открывающая `{` класса и метода — на новой строке | `class User` + перевод строки + `{` |
| 8 | PSR-12 | Открывающая `{` `if`/`for`/`while`/`foreach` — на той же строке | `if ($x) {` |
| 9 | PSR-12 | Между аргументами — пробел после запятой | `function f(int $a, int $b)` |
| 10 | PSR-12 | Пробел после ключевых слов | `if (`, `for (`, `while (` — пробел перед `(` |
| 11 | PSR-12 | Нет пробела перед `(` в вызове функции/метода | `$obj->method(` — без пробела |
| 12 | PSR-12 | Видимость указана явно для каждого свойства и метода | `private`, `public`, `protected` |
| 13 | PSR-12 | `else` и `elseif` на той же строке, что и `}` | `} else {` |
| 14 | PSR-12 | Пустая строка после `namespace` | `namespace App\Models;` + пустая строка |
| 15 | PSR-12 | Каждый `use` — на своей строке | `use App\Models\User;` отдельно |

### Типичные ошибки начинающих и как их диагностировать

Прежде чем переходить к автоматической проверке, полезно знать, какие ошибки встречаются чаще всего и как их визуально распознать.

**Табуляция вместо пробелов.** Если ваш редактор настроен на вставку табуляции при нажатии Tab — это нарушение PSR-12. Настройте VS Code: откроем настройки (`Ctrl+Shift+P` → `Preferences: Open Settings`), найдём `editor.insertSpaces` и установим значение `true`. Размер отступа — 4 пробела: `editor.tabSize` → `4`.

**Забыли указать видимость.** Если вы пишете просто `function getName()` без `public` — это нарушение. В PHP метод без явного модификатора видимости по умолчанию является `public`, но стандарт требует указать это явно. Причина — явность лучше неявности: любой другой разработчик сразу видит намерение автора.

**Скобка `}` на неправильной строке.** Новички часто пишут `} else {` на новой строке, забыв, что `else` должен быть на той же строке, что и закрывающая скобка предыдущего блока. Правильно: `} else {`. Неправильно: `}` на одной строке, `else {` на другой.

**Пробел перед скобкой вызова метода.** Пишут `$user->getName ()` с пробелом перед `()`. PSR-12 запрещает пробел в этом месте. Пробел нужен только после *ключевых слов* — `if`, `for`, `while`, `foreach`, `switch` — но не перед скобками вызова функций и методов.

### Задание 2.1. Установка инструмента проверки кода

Для автоматической проверки кода на соответствие стандартам PSR используется инструмент **PHP_CodeSniffer** (сокращённо — phpcs). Установим его как dev-зависимость:

```bash
composer require --dev squizlabs/php_codesniffer
```

Ключ `--dev` указывает, что это зависимость для разработки — она попадёт в секцию `require-dev` файла `composer.json` и не будет устанавливаться на продакшн-сервере.

После установки инструмент доступен через:

```bash
./vendor/bin/phpcs
```

### Задание 2.2. Проверка текущего кода

Запустим проверку всех файлов в директории `src/` на соответствие стандарту PSR-12:

```bash
./vendor/bin/phpcs src/ --standard=PSR12
```

Если все файлы написаны корректно, инструмент вернет пустой вывод. Теперь специально создадим файл с грубыми нарушением стандартов, чтобы увидеть, как работает phpcs. Создадим файл `src/App/Models/BadlyFormattedClass.php`:

```php
<?php
namespace App\Models;
class badly_formatted_class {
    public $Name;
    private $email ;
    const status = 'active';
    public function GetName( ){
        return $this->Name;
        }
    public function setEmail(string $email ){
            $this->email=$email;
    }
    public function getStatus(): string{
        if($this->Name != ''){
            return self::status;}
        else{
            return 'inactive';
        }
    }
}
?>
```

Запускаем проверку:

```bash
./vendor/bin/phpcs src/App/Models/BadlyFormattedClass.php --standard=PSR12
```

Инструмент выведет список нарушений с указанием номера строки, типа ошибки и описания правила. Проанализируем каждое нарушение и исправим файл.

Вот список проблем, которые должен найти phpcs в этом файле:

- Имя класса `badly_formatted_class` — должно быть `PascalCase`, например `BadlyFormattedClass`;
- Константа `status` — должна быть `STATUS` (заглавные буквы);
- Между `namespace` и объявлением класса должна быть пустая строка;
- Открывающая скобка класса должна быть на новой строке;
- Открывающая скобка методов должна быть на новой строке;
- Лишний пробел перед запятой и скобкой в ряде мест;
- Отсутствие пробелов вокруг оператора присвоения `=`;
- Закрывающий тег `?>` не должен присутствовать в файлах, содержащих только PHP;
- Скобки условных операторов `if`/`else` должны быть на той же строке, что и ключевое слово.

Исправим файл, переписав его в соответствии со стандартом PSR-12:

```php
<?php

namespace App\Models;

class BadlyFormattedClass
{
    public string $name;
    private string $email = '';
    const STATUS = 'active';

    public function getName(): string
    {
        return $this->name;
    }

    public function setEmail(string $email): void
    {
        $this->email = $email;
    }

    public function getStatus(): string
    {
        if ($this->name !== '') {
            return self::STATUS;
        } else {
            return 'inactive';
        }
    }
}
```

Запустим проверку заново:

```bash
./vendor/bin/phpcs src/App/Models/BadlyFormattedClass.php --standard=PSR12
```

Теперь вывод должен быть пустым — все нарушения устранены. Удалим тестовый файл, так как он больше не нужен:

```bash
rm src/App/Models/BadlyFormattedClass.php
```

### Задание 2.3. Автоматическое исправление нарушений

Помимо проверки, PHP_CodeSniffer поставляется с утилитой **phpcbf** (PHP Code Beautifier and Fixer), которая может автоматически исправить часть нарушений. Создадим ещё один тестовый файл с нарушениями, но такими, которые phpcbf способен исправить:

```php
<?php

namespace App\Models;

class AutoFixDemo
{
    private string $value;
    public function setValue(string $value): void
    {
            $this->value = $value;
    }

    public function getValue(): string
    {
            return $this->value;
    }
}
```

В этом файле отступы внутри методов неверные (использовано 12 пробелов вместо 8). Запустим автоматический фиксер:

```bash
./vendor/bin/phpcbf src/App/Models/AutoFixDemo.php --standard=PSR12
```

Инструмент вернет отчёт о том, сколько файлов было изменено и сколько ошибок исправлено. Откроем файл и убедимся, что отступы теперь корректны.

> **Важно.** phpcbf может исправить только *форматные* нарушения: отступы, пробелы, расстановку скобок. Он не может исправить семантические нарушения — например, переименовать класс из `bad_name` в `BadName`. Такие вещи требуют ручного вмешательства.

Удалим тестовый файл:

```bash
rm src/App/Models/AutoFixDemo.php
```

### Задание 2.4. Проверка всего проекта

Запустим проверку всех PHP-файлов проекта:

```bash
./vendor/bin/phpcs src/ --standard=PSR12
```

Все файлы, созданные в ходе этой лабораторной работы, должны проходить проверку без замечаний. Если появятся нарушения — исправьте их.

---

## Часть 3. Контрольные задания

### Задание 3.1

Создайте файл `src/App/Exceptions/NotFoundException.php` с классом `NotFoundException`, который расширяет `\RuntimeException`. Класс должен принимать в конструкторе строку `$entity` (имя сущности, например, «Пользователь») и целое число `$id` (идентификатор). Сообщение исключения должно генерироваться в формате: `{entity} с ID {id} не найден`. Добавьте метод `getEntity(): string` и `getId(): int`.

### Задание 3.2

Создайте файл `src/App/Services/UserRepository.php` с классом `UserRepository`. Класс должен хранить массив объектов `User` (предварительно заполненный в конструкторе тестовыми данными — минимум 3 пользователя). Реализуйте метод `findById(int $id): User`, который возвращает пользователя по идентификатору. Если пользователь не найден — бросайте `NotFoundException`. Также реализуйте метод `findAll(): array`, возвращающий массив всех пользователей.

Для реализации вам потребуется добавить свойство `$id` в класс `User` из предыдущей лабораторной работы. Добавьте его первым параметром конструктора.

### Задание 3.3

Обновите класс `App` так, чтобы он демонстрировал работу `UserRepository`: выводил список всех пользователей и обрабатывал попытку найти несуществующего пользователя (поймав `NotFoundException`).

### Задание 3.4

Запустите `phpcs` на всех файлах проекта. Убедитесь, что **все** файлы проходят проверку на стандарт PSR-12 без единого замечания. Если есть нарушения — исправьте их.

---

## Часть 4. Итоговая структура проекта

После выполнения всех заданий ваш проект должен иметь следующую структуру:

```
composer-lab/
├── src/
│   ├── App/
│   │   ├── Exceptions/
│   │   │   ├── ValidationException.php
│   │   │   └── NotFoundException.php          ← задание 3.1
│   │   ├── External/
│   │   │   └── User.php
│   │   ├── Models/
│   │   │   └── User.php                        ← обновлён в задании 3.2
│   │   ├── Services/
│   │   │   ├── AuthService.php
│   │   │   ├── GreeterService.php
│   │   │   ├── UserValidator.php
│   │   │   └── UserRepository.php             ← задание 3.2
│   │   └── App.php                            ← обновлён в задании 3.3
│   └── Utils/
│       ├── MathHelper.php
│       └── StringHelpers.php
├── vendor/
├── .gitignore
├── composer.json
├── composer.lock
└── index.php
```

Финальный `composer.json`:

```json
{
    "name": "student/composer-lab",
    "description": "Лабораторная работа по Composer",
    "type": "project",
    "require": {
        "nesbot/carbon": "^2.72"
    },
    "require-dev": {
        "squizlabs/php_codesniffer": "^3.10"
    },
    "authors": [
        {
            "name": "Ваше имя",
            "email": "ваша@почта.com"
        }
    ],
    "autoload": {
        "psr-4": {
            "App\\": "src/App/",
            "Utils\\": "src/Utils/"
        }
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}
```

---

## Контрольные вопросы

1. Что такие псевдонимы (`use ... as`) и в каких ситуациях они необходимы? Приведите пример из этой лабораторной работы.
2. Объясните разницу между `use App\Models\User;` и `use function Utils\titleCase;`. Почему нельзя импортировать функцию просто через `use`?
3. Что такое grouped use и какой эффект он имеет на поведение кода? Является ли он альтернативой или просто удобством синтаксиса?
4. Назовите три правила стандарта PSR-1, касающихся именования. Приведите примеры «правильного» и «неправильного» написания.
5. Почему в PSR-12 открывающая фигурная скобка класса и метода должна быть на новой строке, а скобка `if`/`for`/`while` — на той же строке, что и ключевое слово?
6. Какую часть нарушений может автоматически исправить phpcbf, а какую — нет? Почему существует эта разница?

Ответы на контрольные вопросы нужно оформить в отдельном файле `answers.txt` в корне проекта.

---

## Итог

В ходе этой лабораторной работы была существенно углублена тема пространств имён: были рассмотрены вложенные пространства имён, механизм псевдонимов через `as`, группировка импортов, а также импорт функций и констант из пространств имён. Во второй части были изучены стандарты кодирования PSR-1 и PSR-12, проведена практическая работа с инструментом автоматической проверки PHP_CodeSniffer. Теперь проект полностью соответствует отраслевым стандартам качества кода — тем же стандартам, которым следует Laravel и большинство крупных PHP-проектов.