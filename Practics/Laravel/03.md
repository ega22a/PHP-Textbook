# Система блогов с комментариями и лайками

## Введение

В этой лабораторной работе мы создадим полноценную систему блогов с возможностью добавления постов, комментирования (включая вложенные комментарии) и системой лайков. Мы изучим ключевые концепции Laravel, включая миграции, Eloquent ORM, валидацию через Form Requests, Blade-шаблоны, слоистую архитектуру, middleware и многое другое.

**Цели работы:**

- Научиться создавать сложные связи между моделями
- Освоить полиморфные отношения в Eloquent
- Понять принципы слоистой архитектуры и SOLID
- Научиться правильно организовывать бизнес-логику
- Освоить валидацию через Form Requests
- Изучить работу с middleware и фасадами Laravel

---

## Часть 1. Инициализация проекта и настройка окружения

### Шаг 1.1. Создание нового Laravel-проекта

Откройте терминал и выполните команду для создания нового проекта:

```bash
composer create-project laravel/laravel blog-system
cd blog-system
```

**Что происходит:**

- `composer create-project` скачивает и устанавливает последнюю версию Laravel
- Автоматически создается структура проекта со всеми необходимыми файлами
- Устанавливаются все зависимости из `composer.json`

### Шаг 1.2. Настройка подключения к базе данных

#### Предисловие

Для работы и отработки данной лабораторной работы, вам необходимо настроить базу данных MySQL или MariaDB, настроить пользователя и базу данных. Если вы использованил первичные настройки с введения в данную книгу, то данные для подключения к базе данных следующие:

| Определение | Значение |
| -- | -- |
| Логин | `student` |
| Пароль | `student` |
| Хост | `localhost` |
| Имя базы данных | `st` |

Если вы работаете в сети ГАПОУ СО "Нижнетагильский торгово-экономический колледж", то вам нужно предварительно на сервере базы данных, через [панель управления PHPMyAdmin](http://pma.nttek.loc) добавить новую базу данных и работать с ней.

**При создании базы данных, используйте преффикс.** Например, если в задании будет написано: "*создайте базу данных с именем `blog`*", а вас зовут *Иванов Иван Иванович*, то имя базы данных, которое вы создаете будет названо как: `ivanov_ii_blog`.

Данные для входа в сети ГАПОУ СО "Нижнетагильский торгово-экономический колледж":

| Определение | Значение |
| -- | -- |
| Логин | `student` |
| Пароль | `student` |
| Хост | `pma.nttek.loc` |
| Имя базы данных | *Та база, которую вы создали* |

Откройте файл `.env` в корне проекта и настройте параметры подключения к MySQL:

```env
APP_NAME="Blog System"
APP_ENV=local
APP_DEBUG=true
APP_URL=http://localhost

DB_CONNECTION=mysql
DB_HOST=hostname
DB_PORT=3306
DB_DATABASE=username_blogname
DB_USERNAME=student
DB_PASSWORD=student
```

**Объяснение параметров:**

- `DB_CONNECTION` — тип СУБД (mysql, pgsql, sqlite)
- `DB_HOST` — адрес сервера БД
- `DB_DATABASE` — имя базы данных
- `DB_USERNAME` и `DB_PASSWORD` — учетные данные

### Шаг 1.3. Создание базы данных

Создайте базу данных через командную строку MySQL или phpMyAdmin:

```bash
mysql -u root -p
```

В консоли MySQL выполните:

```sql
CREATE DATABASE blog_system CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
EXIT;
```

**Почему utf8mb4:**

- Поддержка полного набора Unicode символов
- Возможность хранения эмодзи
- Современный стандарт для Laravel-приложений

### Шаг 1.4. Проверка установки

Запустите встроенный сервер разработки:

```bash
php artisan serve
```

Откройте браузер по адресу `http://localhost:8000`. Вы должны увидеть приветственную страницу Laravel.

---

## Часть 2. Миграции — версионирование структуры базы данных

### Шаг 2.1. Концепция миграций в Laravel

**Миграции** — это система контроля версий для вашей базы данных. Они позволяют:

- Определять структуру БД в PHP-коде
- Создавать таблицы и изменять их программно
- Откатывать изменения при необходимости
- Синхронизировать структуру БД между разработчиками

**Основные методы миграций:**

- `up()` — применение изменений (создание/изменение таблиц)
- `down()` — откат изменений (для отмены миграции)

### Шаг 2.2. Модификация таблицы users

Laravel уже содержит базовую миграцию для пользователей. Нам нужно модифицировать её под нашу структуру.

Откройте файл `database/migrations/0001_01_01_000000_create_users_table.php` и модифицируйте метод `up()`:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id(); // BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY
            $table->string('lastname', 50);
            $table->string('firstname', 50);
            $table->string('patronymic', 50)->nullable();
            $table->string('email', 100)->unique();
            $table->string('password');
            $table->rememberToken(); // Для функции "Запомнить меня"
            $table->timestamps(); // created_at и updated_at
            
            // Составной индекс для быстрого поиска по имени
            $table->index(['lastname', 'firstname'], 'idx_lastname_firstname');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('users');
    }
};
```

**Объяснение конструкций Blueprint:**

- `id()` — создает первичный ключ типа `BIGINT UNSIGNED` с `AUTO_INCREMENT`
- `string('name', length)` — `VARCHAR(length)`
- `nullable()` — позволяет `NULL` значения
- `unique()` — создает уникальный индекс
- `timestamps()` — добавляет поля `created_at` и `updated_at` типа `TIMESTAMP`
- `index([...], 'name')` — создает обычный индекс для ускорения запросов

### Шаг 2.3. Создание миграции для таблицы posts

Создайте новую миграцию:

```bash
php artisan make:migration create_posts_table
```

**Что делает эта команда:**

- Создает файл в директории `database/migrations/`
- Имя файла содержит timestamp для сохранения порядка выполнения
- Генерирует шаблон с методами `up()` и `down()`

Откройте созданный файл и заполните:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('posts', function (Blueprint $table) {
            $table->id();
            $table->string('heading', 200);
            $table->text('body');
            
            // Внешний ключ на пользователя
            $table->foreignId('user_id')
                  ->constrained('users')
                  ->onDelete('cascade');
            
            $table->timestamps();
            
            // Индекс для поиска по заголовку (первые 100 символов)
            $table->index(DB::raw('heading(100)'), 'idx_heading');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('posts');
    }
};
```

**Объяснение внешних ключей:**

- `foreignId('user_id')` — создает колонку `BIGINT UNSIGNED`
- `constrained('users')` — создает внешний ключ на таблицу users
- `onDelete('cascade')` — при удалении пользователя удаляются все его посты
- Альтернативы: `onDelete('set null')`, `onDelete('restrict')`

**Работа с индексами:**

- Обычные индексы ускоряют поиск и сортировку
- Индекс на части строки `heading(100)` экономит место
- Используйте индексы на колонках, по которым часто ищете или сортируете

### Шаг 2.4. Создание миграции для таблицы comments

```bash
php artisan make:migration create_comments_table
```

Заполните миграцию:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('comments', function (Blueprint $table) {
            $table->id();
            $table->text('body');
            
            // Внешний ключ на пост
            $table->foreignId('post_id')
                  ->constrained('posts')
                  ->onDelete('cascade');
            
            // Внешний ключ на пользователя
            $table->foreignId('user_id')
                  ->constrained('users')
                  ->onDelete('cascade');
            
            // Самоссылающийся внешний ключ для вложенных комментариев
            $table->foreignId('parent_id')
                  ->nullable()
                  ->constrained('comments')
                  ->onDelete('cascade');
            
            $table->timestamps();
            
            // Индексы для оптимизации запросов
            $table->index('post_id', 'idx_post_id');
            $table->index('parent_id', 'idx_parent_id');
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('comments');
    }
};
```

**Важная концепция — самоссылающиеся связи:**

- `parent_id` указывает на другой комментарий в той же таблице
- Позволяет создавать древовидные структуры (ответы на комментарии)
- `nullable()` означает, что корневые комментарии не имеют родителя

### Шаг 2.5. Создание миграции для таблицы likes (полиморфные отношения)

```bash
php artisan make:migration create_likes_table
```

Заполните:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('likes', function (Blueprint $table) {
            $table->id();
            
            $table->foreignId('user_id')
                  ->constrained('users')
                  ->onDelete('cascade');
            
            // Полиморфные отношения
            // Позволяют лайкать разные типы объектов
            $table->string('likeable_type', 50); // 'App\Models\Post' или 'App\Models\Comment'
            $table->unsignedBigInteger('likeable_id'); // ID поста или комментария
            
            $table->timestamp('created_at')->useCurrent();
            
            // Уникальный составной индекс
            // Один пользователь может лайкнуть объект только один раз
            $table->unique(
                ['user_id', 'likeable_type', 'likeable_id'],
                'idx_unique_like'
            );
            
            // Индекс для поиска всех лайков объекта
            $table->index(
                ['likeable_type', 'likeable_id'],
                'idx_likeable_type_id'
            );
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('likes');
    }
};
```

**Полиморфные отношения — мощная концепция Laravel:**

- Одна таблица может хранить связи с разными моделями
- `likeable_type` хранит имя класса модели
- `likeable_id` хранит ID записи
- Избегаем дублирования таблиц (likes_posts, likes_comments)

### Шаг 2.6. Применение миграций

Выполните миграции:

```bash
php artisan migrate
```

**Полезные команды для работы с миграциями:**

```bash
# Посмотреть статус миграций
php artisan migrate:status

# Откатить последнюю партию миграций
php artisan migrate:rollback

# Откатить все миграции
php artisan migrate:reset

# Откатить все миграции и применить заново
php artisan migrate:refresh

# Удалить все таблицы и создать заново (осторожно с данными!)
php artisan migrate:fresh

# Применить конкретную миграцию
php artisan migrate --path=/database/migrations/2024_01_01_create_posts_table.php
```

---

## Часть 3. Модели Eloquent ORM — объектно-реляционное отображение

### Шаг 3.1. Что такое Eloquent ORM

**Eloquent** — это реализация паттерна ActiveRecord в Laravel. Каждая таблица БД имеет соответствующую модель.

**Преимущества Eloquent:**

- Читаемый, выразительный синтаксис
- Автоматическая защита от SQL-инъекций
- Удобная работа со связями между таблицами
- Автоматическое управление timestamps
- Поддержка аксессоров и мутаторов

### Шаг 3.2. Модель User

Модель User уже существует в `app/Models/User.php`. Модифицируем её:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Database\Eloquent\Relations\HasMany;

class User extends Authenticatable
{
    use HasFactory, Notifiable;

    /**
     * Массово заполняемые атрибуты
     * Защита от массового заполнения (Mass Assignment)
     */
    protected $fillable = [
        'lastname',
        'firstname',
        'patronymic',
        'email',
        'password',
    ];

    /**
     * Скрытые атрибуты (не включаются в JSON)
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Приведение типов атрибутов
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed', // Автоматическое хеширование
        ];
    }

    /**
     * Отношение: пользователь имеет много постов
     */
    public function posts(): HasMany
    {
        return $this->hasMany(Post::class);
    }

    /**
     * Отношение: пользователь имеет много комментариев
     */
    public function comments(): HasMany
    {
        return $this->hasMany(Comment::class);
    }

    /**
     * Отношение: пользователь имеет много лайков
     */
    public function likes(): HasMany
    {
        return $this->hasMany(Like::class);
    }

    /**
     * Аксессор: получение полного имени
     * Использование: $user->full_name
     */
    public function getFullNameAttribute(): string
    {
        return trim("{$this->lastname} {$this->firstname} {$this->patronymic}");
    }

    /**
     * Аксессор: получение инициалов
     */
    public function getInitialsAttribute(): string
    {
        $patronymic = $this->patronymic 
            ? ' ' . mb_substr($this->patronymic, 0, 1) . '.' 
            : '';
        
        return $this->lastname . ' ' 
             . mb_substr($this->firstname, 0, 1) . '.' 
             . $patronymic;
    }
}
```

**Объяснение ключевых концепций:**

1. **Mass Assignment Protection:**
   - `$fillable` — белый список полей для массового заполнения
   - Защищает от уязвимости, когда злоумышленник может изменить поля

2. **Аксессоры (Accessors):**
   - Методы вида `getXxxAttribute()`
   - Вычисляемые атрибуты, которые не хранятся в БД
   - Доступ через snake_case: `$user->full_name`

3. **Приведение типов (Casting):**
   - Автоматическое преобразование типов при чтении/записи
   - `hashed` — автоматическое хеширование паролей

### Шаг 3.3. Создание модели Post

```bash
php artisan make:model Post
```

Откройте `app/Models/Post.php`:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

class Post extends Model
{
    use HasFactory;

    protected $fillable = [
        'heading',
        'body',
        'user_id',
    ];

    /**
     * Отношение: пост принадлежит пользователю
     * Обратная связь к hasMany
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Отношение: пост имеет много комментариев
     */
    public function comments(): HasMany
    {
        return $this->hasMany(Comment::class);
    }

    /**
     * Полиморфное отношение: пост может иметь много лайков
     * morphMany автоматически работает с likeable_type и likeable_id
     */
    public function likes(): MorphMany
    {
        return $this->morphMany(Like::class, 'likeable');
    }

    /**
     * Получить только корневые комментарии (без parent_id)
     */
    public function rootComments(): HasMany
    {
        return $this->hasMany(Comment::class)
                    ->whereNull('parent_id')
                    ->with('replies'); // Жадная загрузка ответов
    }

    /**
     * Количество лайков (можно кешировать)
     */
    public function likesCount(): int
    {
        return $this->likes()->count();
    }

    /**
     * Проверка: лайкнул ли текущий пользователь пост
     */
    public function isLikedByUser(?User $user = null): bool
    {
        if (!$user) {
            return false;
        }

        return $this->likes()
                    ->where('user_id', $user->id)
                    ->exists();
    }

    /**
     * Аксессор: краткое описание поста (первые 150 символов)
     */
    public function getExcerptAttribute(): string
    {
        return mb_substr(strip_tags($this->body), 0, 150) . '...';
    }
}
```

**Типы отношений в Eloquent:**

- `hasMany` — один ко многим (у пользователя много постов)
- `belongsTo` — обратная связь (пост принадлежит пользователю)
- `morphMany` — полиморфное отношение один ко многим

### Шаг 3.4. Создание модели Comment

```bash
php artisan make:model Comment
```

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

class Comment extends Model
{
    use HasFactory;

    protected $fillable = [
        'body',
        'post_id',
        'user_id',
        'parent_id',
    ];

    /**
     * Комментарий принадлежит посту
     */
    public function post(): BelongsTo
    {
        return $this->belongsTo(Post::class);
    }

    /**
     * Комментарий принадлежит пользователю
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Родительский комментарий (для вложенных комментариев)
     */
    public function parent(): BelongsTo
    {
        return $this->belongsTo(Comment::class, 'parent_id');
    }

    /**
     * Дочерние комментарии (ответы на этот комментарий)
     */
    public function replies(): HasMany
    {
        return $this->hasMany(Comment::class, 'parent_id');
    }

    /**
     * Полиморфное отношение: лайки комментария
     */
    public function likes(): MorphMany
    {
        return $this->morphMany(Like::class, 'likeable');
    }

    /**
     * Количество лайков
     */
    public function likesCount(): int
    {
        return $this->likes()->count();
    }

    /**
     * Проверка лайка пользователем
     */
    public function isLikedByUser(?User $user = null): bool
    {
        if (!$user) {
            return false;
        }

        return $this->likes()
                    ->where('user_id', $user->id)
                    ->exists();
    }

    /**
     * Проверка: является ли комментарий корневым
     */
    public function isRoot(): bool
    {
        return is_null($this->parent_id);
    }
}
```

### Шаг 3.5. Создание модели Like

```bash
php artisan make:model Like
```

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;

class Like extends Model
{
    use HasFactory;

    // Отключаем updated_at (лайки не редактируются)
    public const UPDATED_AT = null;

    protected $fillable = [
        'user_id',
        'likeable_type',
        'likeable_id',
    ];

    /**
     * Лайк принадлежит пользователю
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Полиморфное отношение: получить объект лайка
     * Может вернуть Post или Comment
     */
    public function likeable(): MorphTo
    {
        return $this->morphTo();
    }
}
```

---

## Часть 4. Валидация данных через Form Requests

### Шаг 4.1. Зачем нужны Form Requests

**Form Request** — специальный класс для валидации входящих данных.

**Преимущества Form Requests:**
1. **Разделение ответственности (Single Responsibility Principle)**
   - Контроллер не загроможден логикой валидации
   - Валидация переиспользуется между контроллерами

2. **Централизация правил валидации**
   - Все правила в одном месте
   - Легко изменять и тестировать

3. **Авторизация на уровне запроса**
   - Проверка прав доступа до выполнения контроллера

4. **Автоматическая обработка ошибок**
   - Автоматический редирект с ошибками
   - Сохранение старых значений формы

### Шаг 4.2. Создание Form Request для поста

```bash
php artisan make:request StorePostRequest
php artisan make:request UpdatePostRequest
```

Откройте `app/Http/Requests/StorePostRequest.php`:

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StorePostRequest extends FormRequest
{
    /**
     * Определяем, авторизован ли пользователь для этого запроса
     */
    public function authorize(): bool
    {
        // Только авторизованные пользователи могут создавать посты
        return auth()->check();
    }

    /**
     * Правила валидации
     */
    public function rules(): array
    {
        return [
            'heading' => [
                'required',           // Обязательное поле
                'string',             // Должно быть строкой
                'max:200',            // Максимум 200 символов
                'min:5',              // Минимум 5 символов
            ],
            'body' => [
                'required',
                'string',
                'min:10',             // Минимум 10 символов для контента
                'max:50000',          // Защита от слишком больших постов
            ],
        ];
    }

    /**
     * Кастомные сообщения об ошибках
     */
    public function messages(): array
    {
        return [
            'heading.required' => 'Заголовок поста обязателен для заполнения',
            'heading.min' => 'Заголовок должен содержать минимум :min символов',
            'heading.max' => 'Заголовок не должен превышать :max символов',
            'body.required' => 'Содержание поста обязательно для заполнения',
            'body.min' => 'Содержание должно содержать минимум :min символов',
        ];
    }

    /**
     * Кастомные имена атрибутов для ошибок
     */
    public function attributes(): array
    {
        return [
            'heading' => 'заголовок',
            'body' => 'содержание',
        ];
    }

    /**
     * Подготовка данных перед валидацией
     * Можем очистить или модифицировать данные
     */
    protected function prepareForValidation(): void
    {
        $this->merge([
            'heading' => trim($this->heading),
            'body' => trim($this->body),
        ]);
    }
}
```

Откройте `app/Http/Requests/UpdatePostRequest.php`:

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class UpdatePostRequest extends FormRequest
{
    public function authorize(): bool
    {
        // Пользователь может редактировать только свои посты
        $post = $this->route('post'); // Получаем пост из маршрута
        return $post && $this->user()->id === $post->user_id;
    }

    public function rules(): array
    {
        return [
            'heading' => [
                'required',
                'string',
                'max:200',
                'min:5',
            ],
            'body' => [
                'required',
                'string',
                'min:10',
                'max:50000',
            ],
        ];
    }

    public function messages(): array
    {
        return [
            'heading.required' => 'Заголовок поста обязателен',
            'body.required' => 'Содержание поста обязательно',
        ];
    }
}
```

### Шаг 4.3. Form Request для комментариев

```bash
php artisan make:request StoreCommentRequest
```

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

class StoreCommentRequest extends FormRequest
{
    public function authorize(): bool
    {
        return auth()->check();
    }

    public function rules(): array
    {
        return [
            'body' => [
                'required',
                'string',
                'min:2',
                'max:5000',
            ],
            'post_id' => [
                'required',
                'integer',
                'exists:posts,id', // Пост должен существовать
            ],
            'parent_id' => [
                'nullable',
                'integer',
                'exists:comments,id', // Родительский комментарий должен существовать
                // Дополнительная проверка: parent должен быть из того же поста
                Rule::exists('comments', 'id')->where(function ($query) {
                    $query->where('post_id', $this->post_id);
                }),
            ],
        ];
    }

    public function messages(): array
    {
        return [
            'body.required' => 'Комментарий не может быть пустым',
            'body.min' => 'Комментарий слишком короткий',
            'post_id.exists' => 'Пост не найден',
            'parent_id.exists' => 'Родительский комментарий не найден',
        ];
    }
}
```

**Продвинутая валидация:**

- `exists:table,column` — проверка существования записи
- `Rule::exists()` с дополнительными условиями
- Валидация связанных данных (parent_id должен быть из того же поста)

---

## Часть 5. Слоистая архитектура и бизнес-логика (SOLID)

### Шаг 5.1. Принципы SOLID и слоистая архитектура

**SOLID — пять принципов объектно-ориентированного программирования:**

1. **S — Single Responsibility Principle (Принцип единственной ответственности)**
   - Каждый класс должен иметь одну причину для изменения
   - Контроллер не должен содержать бизнес-логику

2. **O — Open/Closed Principle (Принцип открытости/закрытости)**
   - Классы открыты для расширения, но закрыты для модификации
   - Используем интерфейсы и абстрактные классы

3. **L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**
   - Объекты должны быть заменяемы своими наследниками

4. **I — Interface Segregation Principle (Принцип разделения интерфейса)**
   - Много специализированных интерфейсов лучше одного общего

5. **D — Dependency Inversion Principle (Принцип инверсии зависимостей)**
   - Зависимость от абстракций, а не от конкретных реализаций

### Шаг 5.2. Создание сервисного слоя

Создадим директорию для сервисов: `app/Services`

**Сервис для работы с постами:**

Создайте файл `app/Services/PostService.php`:

```php
<?php

namespace App\Services;

use App\Models\Post;
use App\Models\User;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Facades\DB;

class PostService
{
    /**
     * Получить все посты с пагинацией
     */
    public function getAllPosts(int $perPage = 10): LengthAwarePaginator
    {
        return Post::with(['user', 'likes']) // Жадная загрузка
                   ->withCount(['comments', 'likes']) // Добавить счетчики
                   ->latest() // Сортировка по created_at DESC
                   ->paginate($perPage);
    }

    /**
     * Получить пост со всеми связями
     */
    public function getPostWithRelations(int $postId): ?Post
    {
        return Post::with([
            'user',
            'rootComments.user',
            'rootComments.replies.user',
            'rootComments.likes',
            'rootComments.replies.likes',
        ])
        ->withCount(['comments', 'likes'])
        ->find($postId);
    }

    /**
     * Создать новый пост
     */
    public function createPost(array $data, User $user): Post
    {
        // Используем транзакцию для атомарности операции
        return DB::transaction(function () use ($data, $user) {
            $post = new Post();
            $post->heading = $data['heading'];
            $post->body = $data['body'];
            $post->user_id = $user->id;
            $post->save();

            return $post;
        });
    }

    /**
     * Обновить пост
     */
    public function updatePost(Post $post, array $data): Post
    {
        return DB::transaction(function () use ($post, $data) {
            $post->heading = $data['heading'];
            $post->body = $data['body'];
            $post->save();

            return $post;
        });
    }

    /**
     * Удалить пост
     */
    public function deletePost(Post $post): bool
    {
        return DB::transaction(function () use ($post) {
            // Благодаря cascade в БД, комментарии и лайки удалятся автоматически
            return $post->delete();
        });
    }

    /**
     * Получить посты пользователя
     */
    public function getUserPosts(User $user, int $perPage = 10): LengthAwarePaginator
    {
        return $user->posts()
                    ->withCount(['comments', 'likes'])
                    ->latest()
                    ->paginate($perPage);
    }
}
```

**Создайте сервис для лайков:**

`app/Services/LikeService.php`:

```php
<?php

namespace App\Services;

use App\Models\Like;
use App\Models\User;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;

class LikeService
{
    /**
     * Переключить лайк (поставить или убрать)
     */
    public function toggleLike(Model $likeable, User $user): array
    {
        return DB::transaction(function () use ($likeable, $user) {
            $like = Like::where('user_id', $user->id)
                        ->where('likeable_type', get_class($likeable))
                        ->where('likeable_id', $likeable->id)
                        ->first();

            if ($like) {
                // Лайк существует — удаляем
                $like->delete();
                return [
                    'action' => 'removed',
                    'likes_count' => $likeable->likes()->count(),
                ];
            } else {
                // Лайка нет — создаем
                Like::create([
                    'user_id' => $user->id,
                    'likeable_type' => get_class($likeable),
                    'likeable_id' => $likeable->id,
                ]);
                return [
                    'action' => 'added',
                    'likes_count' => $likeable->likes()->count(),
                ];
            }
        });
    }

    /**
     * Проверить, лайкнул ли пользователь объект
     */
    public function isLikedBy(Model $likeable, User $user): bool
    {
        return Like::where('user_id', $user->id)
                   ->where('likeable_type', get_class($likeable))
                   ->where('likeable_id', $likeable->id)
                   ->exists();
    }
}
```

**Сервис для комментариев:**

`app/Services/CommentService.php`:

```php
<?php

namespace App\Services;

use App\Models\Comment;
use App\Models\Post;
use App\Models\User;
use Illuminate\Support\Facades\DB;

class CommentService
{
    /**
     * Создать комментарий
     */
    public function createComment(array $data, User $user): Comment
    {
        return DB::transaction(function () use ($data, $user) {
            $comment = new Comment();
            $comment->body = $data['body'];
            $comment->post_id = $data['post_id'];
            $comment->user_id = $user->id;
            $comment->parent_id = $data['parent_id'] ?? null;
            $comment->save();

            return $comment->load('user'); // Загружаем пользователя
        });
    }

    /**
     * Удалить комментарий
     */
    public function deleteComment(Comment $comment): bool
    {
        return DB::transaction(function () use ($comment) {
            // Все дочерние комментарии удалятся благодаря cascade
            return $comment->delete();
        });
    }

    /**
     * Получить комментарии поста древовидной структурой
     */
    public function getPostCommentsTree(Post $post)
    {
        return $post->rootComments()
                    ->with(['user', 'replies.user', 'replies.likes'])
                    ->withCount('likes')
                    ->get();
    }
}
```

**Преимущества сервисного слоя:**

- Переиспользование бизнес-логики
- Легкое тестирование (можем мокировать сервисы)
- Контроллеры становятся тонкими и читаемыми
- Транзакции изолированы в одном месте

> **Мокирование** - это создание поддельных объектов для тестирования, которые имитируют поведение реальных объектов. Оно полезно для изоляции тестов и проверки взаимодействий между компонентами.

---

## Часть 6. Контроллеры — управление HTTP-запросами

### Шаг 6.1. Контроллер для постов

```bash
php artisan make:controller PostController --resource
```

Откройте `app/Http/Controllers/PostController.php`:

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StorePostRequest;
use App\Http\Requests\UpdatePostRequest;
use App\Models\Post;
use App\Services\PostService;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;

class PostController extends Controller
{
    public function __construct(
        private PostService $postService
    ) {
        // Middleware: только авторизованные могут создавать/редактировать
        $this->middleware('auth')->except(['index', 'show']);
    }

    /**
     * Список всех постов
     */
    public function index(): View
    {
        $posts = $this->postService->getAllPosts(perPage: 15);
        
        return view('posts.index', compact('posts'));
    }

    /**
     * Форма создания поста
     */
    public function create(): View
    {
        return view('posts.create');
    }

    /**
     * Сохранение нового поста
     */
    public function store(StorePostRequest $request): RedirectResponse
    {
        // Данные уже валидированы в StorePostRequest
        $post = $this->postService->createPost(
            $request->validated(),
            $request->user()
        );

        return redirect()
            ->route('posts.show', $post)
            ->with('success', 'Пост успешно создан!');
    }

    /**
     * Просмотр одного поста
     */
    public function show(Post $post): View
    {
        // Route Model Binding автоматически загружает пост
        $post = $this->postService->getPostWithRelations($post->id);
        
        return view('posts.show', compact('post'));
    }

    /**
     * Форма редактирования поста
     */
    public function edit(Post $post): View
    {
        // Проверка прав через Policy (создадим позже)
        $this->authorize('update', $post);
        
        return view('posts.edit', compact('post'));
    }

    /**
     * Обновление поста
     */
    public function update(UpdatePostRequest $request, Post $post): RedirectResponse
    {
        // Авторизация уже проверена в UpdatePostRequest
        $post = $this->postService->updatePost($post, $request->validated());

        return redirect()
            ->route('posts.show', $post)
            ->with('success', 'Пост успешно обновлен!');
    }

    /**
     * Удаление поста
     */
    public function destroy(Post $post): RedirectResponse
    {
        $this->authorize('delete', $post);
        
        $this->postService->deletePost($post);

        return redirect()
            ->route('posts.index')
            ->with('success', 'Пост успешно удален!');
    }
}
```

**Ключевые концепции контроллера:**

1. **Dependency Injection (Внедрение зависимостей):**
   - `PostService` автоматически создается и внедряется Laravel
   - Следование принципу Dependency Inversion

2. **Route Model Binding:**
   - Laravel автоматически находит Post по ID из URL
   - `Route::get('/posts/{post}')` → метод получает объект Post

3. **Type Hinting:**
   - Явное указание типов параметров и возвращаемых значений
   - Улучшает читаемость и предотвращает ошибки

### Шаг 6.2. Контроллер для комментариев

```bash
php artisan make:controller CommentController
```

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreCommentRequest;
use App\Models\Comment;
use App\Services\CommentService;
use Illuminate\Http\RedirectResponse;

class CommentController extends Controller
{
    public function __construct(
        private CommentService $commentService
    ) {
        $this->middleware('auth');
    }

    /**
     * Создание комментария
     */
    public function store(StoreCommentRequest $request): RedirectResponse
    {
        $comment = $this->commentService->createComment(
            $request->validated(),
            $request->user()
        );

        return redirect()
            ->route('posts.show', $comment->post_id)
            ->with('success', 'Комментарий добавлен!');
    }

    /**
     * Удаление комментария
     */
    public function destroy(Comment $comment): RedirectResponse
    {
        // Только автор может удалить комментарий
        if ($comment->user_id !== auth()->id()) {
            abort(403, 'Вы не можете удалить чужой комментарий');
        }

        $postId = $comment->post_id;
        $this->commentService->deleteComment($comment);

        return redirect()
            ->route('posts.show', $postId)
            ->with('success', 'Комментарий удален!');
    }
}
```

### Шаг 6.3. Контроллер для лайков

```bash
php artisan make:controller LikeController
```

```php
<?php

namespace App\Http\Controllers;

use App\Models\Post;
use App\Models\Comment;
use App\Services\LikeService;
use Illuminate\Http\JsonResponse;

class LikeController extends Controller
{
    public function __construct(
        private LikeService $likeService
    ) {
        $this->middleware('auth');
    }

    /**
     * Переключение лайка на посте
     */
    public function togglePostLike(Post $post): JsonResponse
    {
        $result = $this->likeService->toggleLike($post, auth()->user());

        return response()->json([
            'success' => true,
            'action' => $result['action'],
            'likes_count' => $result['likes_count'],
        ]);
    }

    /**
     * Переключение лайка на комментарии
     */
    public function toggleCommentLike(Comment $comment): JsonResponse
    {
        $result = $this->likeService->toggleLike($comment, auth()->user());

        return response()->json([
            'success' => true,
            'action' => $result['action'],
            'likes_count' => $result['likes_count'],
        ]);
    }
}
```

**JSON API для AJAX-запросов:**

- Лайки работают без перезагрузки страницы
- Возвращаем JSON с результатом операции
- Frontend JavaScript обрабатывает ответ

---

## Часть 7. Маршрутизация (Routing)

### Шаг 7.1. Определение маршрутов

Откройте `routes/web.php`:

```php
<?php

use App\Http\Controllers\PostController;
use App\Http\Controllers\CommentController;
use App\Http\Controllers\LikeController;
use App\Http\Controllers\ProfileController;
use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| Публичные маршруты
|--------------------------------------------------------------------------
*/

// Главная страница — список постов
Route::get('/', [PostController::class, 'index'])->name('home');

// RESTful маршруты для постов
Route::resource('posts', PostController::class);

/*
|--------------------------------------------------------------------------
| Маршруты, требующие аутентификации
|--------------------------------------------------------------------------
*/

Route::middleware('auth')->group(function () {
    
    // Комментарии
    Route::post('/comments', [CommentController::class, 'store'])
         ->name('comments.store');
    
    Route::delete('/comments/{comment}', [CommentController::class, 'destroy'])
         ->name('comments.destroy');
    
    // Лайки (API маршруты)
    Route::post('/posts/{post}/like', [LikeController::class, 'togglePostLike'])
         ->name('posts.like');
    
    Route::post('/comments/{comment}/like', [LikeController::class, 'toggleCommentLike'])
         ->name('comments.like');
    
    // Профиль пользователя
    Route::get('/profile', [ProfileController::class, 'show'])
         ->name('profile.show');
});
```

**Объяснение концепций маршрутизации:**

1. **RESTful маршруты:**
   - `Route::resource()` создает 7 стандартных маршрутов
   - `GET /posts` — `index`
   - `GET /posts/create` — `create`
   - `POST /posts` — `store`
   - `GET /posts/{id}` — `show`
   - `GET /posts/{id}/edit` — `edit`
   - `PUT/PATCH /posts/{id}` — `update`
   - `DELETE /posts/{id}` — `destroy`
2. **Именованные маршруты:**
   - `->name('posts.show')` создает имя для маршрута
   - Использование: `route('posts.show', $post->id)`
   - Преимущество: изменяете URL в одном месте

3. **Группировка маршрутов:**
   - `Route::middleware('auth')->group()` применяет middleware ко всем маршрутам в группе
   - Упрощает организацию кода

### Шаг 7.2. Просмотр всех маршрутов

```bash
php artisan route:list
```

Эта команда показывает все зарегистрированные маршруты, их методы, URI и контроллеры.

---

## Часть 8. Middleware — промежуточное ПО

### Шаг 8.1. Что такое Middleware

**Middleware** — это фильтры HTTP-запросов. Они выполняются до или после обработки запроса контроллером.

**Типичные применения:**
- Аутентификация (проверка авторизации)
- CORS (кросс-доменные запросы)
- Логирование запросов
- Ограничение частоты запросов (Rate Limiting)

**Встроенные middleware Laravel:**
- `auth` — требует аутентификации
- `guest` — только для гостей
- `throttle` — ограничение частоты запросов
- `verified` — требует подтверждения email

### Шаг 8.2. Создание кастомного Middleware

Создадим middleware для логирования действий пользователя:

```bash
php artisan make:middleware LogUserActivity
```

Откройте `app/Http/Middleware/LogUserActivity.php`:

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response;

class LogUserActivity
{
    /**
     * Обработка входящего запроса
     */
    public function handle(Request $request, Closure $next): Response
    {
        // Код ДО выполнения контроллера
        
        if (auth()->check()) {
            Log::info('User activity', [
                'user_id' => auth()->id(),
                'email' => auth()->user()->email,
                'url' => $request->fullUrl(),
                'method' => $request->method(),
                'ip' => $request->ip(),
            ]);
        }

        // Передаем запрос дальше по цепочке
        $response = $next($request);

        // Код ПОСЛЕ выполнения контроллера
        // Здесь можно модифицировать ответ

        return $response;
    }
}
```

**Регистрация middleware:**

Откройте `bootstrap/app.php` и добавьте middleware:

```php
->withMiddleware(function (Middleware $middleware) {
    $middleware->alias([
        'log.activity' => \App\Http\Middleware\LogUserActivity::class,
    ]);
})
```

**Использование в маршрутах:**

```php
Route::get('/posts', [PostController::class, 'index'])
     ->middleware('log.activity');
```

### Шаг 8.3. Middleware для проверки владельца поста

```bash
php artisan make:middleware CheckPostOwner
```

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class CheckPostOwner
{
    public function handle(Request $request, Closure $next): Response
    {
        $post = $request->route('post');
        
        if ($post && $post->user_id !== auth()->id()) {
            abort(403, 'У вас нет доступа к этому посту');
        }

        return $next($request);
    }
}
```

---

## Часть 9. Фасады Laravel

### Шаг 9.1. Понимание фасадов

**Фасад** — это статический интерфейс к классу в Service Container.

**Популярные фасады:**
- `Auth` — аутентификация
- `DB` — работа с БД
- `Request` — текущий HTTP-запрос
- `Response` — создание HTTP-ответов
- `Storage` — файловая система
- `Cache` — кеширование

**Примеры использования:**

```php
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Request;
use Illuminate\Support\Facades\Response;

// Аутентификация
$user = Auth::user();
$isAuthenticated = Auth::check();
Auth::logout();

// База данных
DB::table('posts')->where('user_id', 1)->get();
DB::beginTransaction();
DB::commit();
DB::rollBack();

// Запрос
$ip = Request::ip();
$url = Request::url();
$method = Request::method();

// Ответ
return Response::json(['success' => true]);
return Response::view('posts.index', compact('posts'));
return Response::download($pathToFile);
```

---

## Часть 10. Artisan-команды

### Шаг 10.1. Полезные встроенные команды

```bash
# Миграции
php artisan migrate
php artisan migrate:rollback
php artisan migrate:fresh --seed

# Кеш
php artisan cache:clear
php artisan config:cache
php artisan route:cache
php artisan view:clear

# Генерация классов
php artisan make:model Post
php artisan make:controller PostController
php artisan make:migration create_posts_table
php artisan make:request StorePostRequest
php artisan make:middleware CheckAuth

# База данных
php artisan db:seed
php artisan db:show

# Очередь задач
php artisan queue:work
php artisan queue:listen

# Сервер разработки
php artisan serve
php artisan serve --port=8080
```

### Шаг 10.2. Создание собственной Artisan-команды

Создадим команду для генерации тестовых данных:

```bash
php artisan make:command GenerateTestData
```

Откройте `app/Console/Commands/GenerateTestData.php`:

```php
<?php

namespace App\Console\Commands;

use App\Models\User;
use App\Models\Post;
use App\Models\Comment;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Hash;

class GenerateTestData extends Command
{
    /**
     * Сигнатура команды
     */
    protected $signature = 'app:generate-test-data 
                            {users=10 : Количество пользователей}
                            {--posts=5 : Количество постов на пользователя}
                            {--comments=3 : Количество комментариев на пост}';

    /**
     * Описание команды
     */
    protected $description = 'Генерация тестовых данных для блога';

    /**
     * Выполнение команды
     */
    public function handle(): int
    {
        $this->info('Начинаем генерацию тестовых данных...');

        $usersCount = $this->argument('users');
        $postsPerUser = $this->option('posts');
        $commentsPerPost = $this->option('comments');

        // Прогресс-бар для пользователей
        $this->info("Создаём {$usersCount} пользователей...");
        $bar = $this->output->createProgressBar($usersCount);

        for ($i = 1; $i <= $usersCount; $i++) {
            $user = User::create([
                'lastname' => "Фамилия{$i}",
                'firstname' => "Имя{$i}",
                'patronymic' => "Отчество{$i}",
                'email' => "user{$i}@example.com",
                'password' => Hash::make('password'),
            ]);

            // Создаём посты для пользователя
            for ($j = 1; $j <= $postsPerUser; $j++) {
                $post = Post::create([
                    'heading' => "Пост #{$j} пользователя {$user->full_name}",
                    'body' => "Это содержание поста #{$j}. Lorem ipsum dolor sit amet.",
                    'user_id' => $user->id,
                ]);

                // Создаём комментарии к посту
                for ($k = 1; $k <= $commentsPerPost; $k++) {
                    Comment::create([
                        'body' => "Комментарий #{$k} к посту #{$post->id}",
                        'post_id' => $post->id,
                        'user_id' => User::inRandomOrder()->first()->id,
                        'parent_id' => null,
                    ]);
                }
            }

            $bar->advance();
        }

        $bar->finish();
        $this->newLine();

        $this->info('✓ Данные успешно сгенерированы!');
        $this->table(
            ['Тип', 'Количество'],
            [
                ['Пользователи', $usersCount],
                ['Посты', $usersCount * $postsPerUser],
                ['Комментарии', $usersCount * $postsPerUser * $commentsPerPost],
            ]
        );

        return Command::SUCCESS;
    }
}
```

**Запуск команды:**

```bash
php artisan app:generate-test-data 20 --posts=10 --comments=5
```

**Объяснение:**

- `{users=10}` — обязательный аргумент с значением по умолчанию
- `{--posts=5}` — опция с значением
- `$this->info()` — вывод информационного сообщения
- `$this->table()` — вывод таблицы
- Прогресс-бар для визуализации процесса

---

## Часть 11. Blade-шаблоны и CSS

### Шаг 11.1. Создание главного layout

Создайте файл `resources/views/layouts/app.blade.php`:

```blade
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>@yield('title', 'Блог-система')</title>
    
    {{-- Подключение CSS --}}
    <link rel="stylesheet" href="{{ asset('css/app.css') }}">
</head>
<body>
    {{-- Навигация --}}
    <nav class="navbar">
        <div class="container">
            <a href="{{ route('home') }}" class="logo">BlogSystem</a>
            
            <div class="nav-links">
                <a href="{{ route('posts.index') }}">Все посты</a>
                
                @auth
                    <a href="{{ route('posts.create') }}">Создать пост</a>
                    <a href="{{ route('profile.show') }}">Профиль</a>
                    
                    <form method="POST" action="{{ route('logout') }}" style="display: inline;">
                        @csrf
                        <button type="submit" class="btn-link">Выйти</button>
                    </form>
                @else
                    <a href="{{ route('login') }}">Войти</a>
                    <a href="{{ route('register') }}">Регистрация</a>
                @endauth
            </div>
        </div>
    </nav>

    {{-- Сообщения об успехе/ошибках --}}
    @if(session('success'))
        <div class="alert alert-success">
            {{ session('success') }}
        </div>
    @endif

    @if(session('error'))
        <div class="alert alert-error">
            {{ session('error') }}
        </div>
    @endif

    {{-- Основной контент --}}
    <main class="container">
        @yield('content')
    </main>

    {{-- Подключение JavaScript --}}
    <script src="{{ asset('js/app.js') }}"></script>
    @stack('scripts')
</body>
</html>
```

**Blade-директивы:**

- `@yield('name')` — место для вставки контента из дочернего шаблона
- `@auth` — блок для авторизованных пользователей
- `@guest` — блок для гостей
- `@csrf` — токен для защиты от CSRF
- `@stack('scripts')` — стек для добавления скриптов из дочерних шаблонов

### Шаг 11.2. Шаблон списка постов

Создайте `resources/views/posts/index.blade.php`:

```blade
@extends('layouts.app')

@section('title', 'Все посты')

@section('content')
    <div class="posts-header">
        <h1>Все посты</h1>
        
        @auth
            <a href="{{ route('posts.create') }}" class="btn btn-primary">
                Создать пост
            </a>
        @endauth
    </div>

    <div class="posts-grid">
        @forelse($posts as $post)
            <article class="post-card">
                <div class="post-header">
                    <h2>
                        <a href="{{ route('posts.show', $post) }}">
                            {{ $post->heading }}
                        </a>
                    </h2>
                    <span class="post-date">
                        {{ $post->created_at->format('d.m.Y') }}
                    </span>
                </div>

                <p class="post-excerpt">
                    {{ $post->excerpt }}
                </p>

                <div class="post-meta">
                    <span class="author">
                        {{ $post->user->full_name }}
                    </span>
                    
                    <div class="post-stats">
                        <span>💬 {{ $post->comments_count }}</span>
                        <span>❤️ {{ $post->likes_count }}</span>
                    </div>
                </div>
            </article>
        @empty
            <p class="no-posts">Пока нет ни одного поста.</p>
        @endforelse
    </div>

    {{-- Пагинация --}}
    <div class="pagination">
        {{ $posts->links() }}
    </div>
@endsection
```

**Blade-директивы циклов:**

- `@forelse...@empty...@endforelse` — цикл с обработкой пустого массива
- `@foreach...@endforeach` — стандартный цикл

### Шаг 11.3. Шаблон просмотра поста

Создайте `resources/views/posts/show.blade.php`:

```blade
@extends('layouts.app')

@section('title', $post->heading)

@section('content')
    <article class="post-detail">
        <header class="post-detail-header">
            <h1>{{ $post->heading }}</h1>
            
            <div class="post-meta-full">
                <span class="author">
                    Автор: {{ $post->user->full_name }}
                </span>
                <span class="date">
                    {{ $post->created_at->format('d.m.Y H:i') }}
                </span>
            </div>

            @can('update', $post)
                <div class="post-actions">
                    <a href="{{ route('posts.edit', $post) }}" class="btn btn-sm">
                        Редактировать
                    </a>
                    
                    <form method="POST" action="{{ route('posts.destroy', $post) }}" 
                          onsubmit="return confirm('Удалить пост?')">
                        @csrf
                        @method('DELETE')
                        <button type="submit" class="btn btn-sm btn-danger">
                            Удалить
                        </button>
                    </form>
                </div>
            @endcan
        </header>

        <div class="post-content">
            {!! nl2br(e($post->body)) !!}
        </div>

        <div class="post-footer">
            <button 
                class="like-btn {{ $post->isLikedByUser(auth()->user()) ? 'liked' : '' }}" 
                data-post-id="{{ $post->id }}"
                data-url="{{ route('posts.like', $post) }}">
                ❤️ <span class="likes-count">{{ $post->likes_count }}</span>
            </button>
        </div>
    </article>

    {{-- Комментарии --}}
    <section class="comments-section">
        <h2>Комментарии ({{ $post->comments_count }})</h2>

        @auth
            <form method="POST" action="{{ route('comments.store') }}" class="comment-form">
                @csrf
                <input type="hidden" name="post_id" value="{{ $post->id }}">
                
                <textarea 
                    name="body" 
                    placeholder="Ваш комментарий..." 
                    rows="3"
                    required
                >{{ old('body') }}</textarea>
                
                @error('body')
                    <span class="error">{{ $message }}</span>
                @enderror
                
                <button type="submit" class="btn btn-primary">
                    Отправить
                </button>
            </form>
        @else
            <p class="auth-message">
                <a href="{{ route('login') }}">Войдите</a>, чтобы оставить комментарий
            </p>
        @endauth

        {{-- Список комментариев --}}
        <div class="comments-list">
            @foreach($post->rootComments as $comment)
                @include('partials.comment', ['comment' => $comment])
            @endforeach
        </div>
    </section>
@endsection

@push('scripts')
    <script src="{{ asset('js/likes.js') }}"></script>
@endpush
```

**Blade-директивы авторизации:**

- `@can('update', $post)` — проверка через Policy
- `@cannot` — обратная проверка

### Шаг 11.4. Partial для комментария (рекурсивный)

Создайте `resources/views/partials/comment.blade.php`:

```blade
<div class="comment" id="comment-{{ $comment->id }}">
    <div class="comment-header">
        <strong>{{ $comment->user->initials }}</strong>
        <span class="comment-date">
            {{ $comment->created_at->diffForHumans() }}
        </span>
    </div>

    <div class="comment-body">
        {{ $comment->body }}
    </div>

    <div class="comment-actions">
        <button 
            class="like-btn-comment {{ $comment->isLikedByUser(auth()->user()) ? 'liked' : '' }}"
            data-comment-id="{{ $comment->id }}"
            data-url="{{ route('comments.like', $comment) }}">
            ❤️ <span>{{ $comment->likes_count }}</span>
        </button>

        @auth
            <button 
                class="reply-btn" 
                data-comment-id="{{ $comment->id }}">
                Ответить
            </button>
        @endauth

        @can('delete', $comment)
            <form method="POST" action="{{ route('comments.destroy', $comment) }}" 
                  onsubmit="return confirm('Удалить комментарий?')">
                @csrf
                @method('DELETE')
                <button type="submit" class="btn-link danger">Удалить</button>
            </form>
        @endcan
    </div>

    {{-- Рекурсивный вывод ответов --}}
    @if($comment->replies->count() > 0)
        <div class="comment-replies">
            @foreach($comment->replies as $reply)
                @include('partials.comment', ['comment' => $reply])
            @endforeach
        </div>
    @endif
</div>
```

**Рекурсивные шаблоны:**

- `@include('partials.comment')` вызывает сам себя для вложенных комментариев
- Создает древовидную структуру

### Шаг 11.5. CSS-стили

Создайте файл `public/css/app.css`:

```css
/* Сброс стилей */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    line-height: 1.6;
    color: #333;
    background: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
}

/* Навигация */
.navbar {
    background: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 1rem 0;
    margin-bottom: 2rem;
}

.navbar .container {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.logo {
    font-size: 1.5rem;
    font-weight: bold;
    color: #3490dc;
    text-decoration: none;
}

.nav-links {
    display: flex;
    gap: 1.5rem;
    align-items: center;
}

.nav-links a {
    color: #333;
    text-decoration: none;
    transition: color 0.3s;
}

.nav-links a:hover {
    color: #3490dc;
}

/* Сообщения */
.alert {
    padding: 1rem;
    margin-bottom: 1rem;
    border-radius: 4px;
}

.alert-success {
    background: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.alert-error {
    background: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

/* Посты - сетка */
.posts-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
}

.posts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 2rem;
    margin-bottom: 2rem;
}

.post-card {
    background: #fff;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: transform 0.3s, box-shadow 0.3s;
}

.post-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
}

.post-header h2 {
    margin-bottom: 0.5rem;
}

.post-header h2 a {
    color: #333;
    text-decoration: none;
}

.post-header h2 a:hover {
    color: #3490dc;
}

.post-date {
    color: #666;
    font-size: 0.9rem;
}

.post-excerpt {
    margin: 1rem 0;
    color: #555;
}

.post-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 1rem;
    border-top: 1px solid #eee;
}

.post-stats {
    display: flex;
    gap: 1rem;
}

/* Детальный пост */
.post-detail {
    background: #fff;
    padding: 2rem;
    border-radius: 8px;
    margin-bottom: 2rem;
}

.post-content {
    margin: 2rem 0;
    line-height: 1.8;
}

.post-actions {
    display: flex;
    gap: 1rem;
}

/* Комментарии */
.comments-section {
    background: #fff;
    padding: 2rem;
    border-radius: 8px;
}

.comment-form textarea {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 1rem;
    font-family: inherit;
}

.comment {
    border-left: 3px solid #3490dc;
    padding-left: 1rem;
    margin-bottom: 1.5rem;
}

.comment-replies {
    margin-left: 2rem;
    margin-top: 1rem;
}

.comment-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.5rem;
}

.comment-date {
    color: #666;
    font-size: 0.85rem;
}

.comment-actions {
    display: flex;
    gap: 1rem;
    margin-top: 0.5rem;
}

/* Кнопки */
.btn {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-decoration: none;
    display: inline-block;
    transition: background 0.3s;
}

.btn-primary {
    background: #3490dc;
    color: #fff;
}

.btn-primary:hover {
    background: #2779bd;
}

.btn-danger {
    background: #e3342f;
    color: #fff;
}

.btn-link {
    background: none;
    border: none;
    color: #3490dc;
    cursor: pointer;
    font-size: inherit;
}

.like-btn, .like-btn-comment {
    background: none;
    border: 1px solid #ddd;
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s;
}

.like-btn.liked, .like-btn-comment.liked {
    background: #e3342f;
    color: #fff;
    border-color: #e3342f;
}

/* Пагинация */
.pagination {
    display: flex;
    justify-content: center;
    margin: 2rem 0;
}

/* Адаптивность */
@media (max-width: 768px) {
    .posts-grid {
        grid-template-columns: 1fr;
    }
    
    .comment-replies {
        margin-left: 1rem;
    }
}
```

### Шаг 11.6. JavaScript для лайков

Создайте `public/js/likes.js`:

```javascript
document.addEventListener('DOMContentLoaded', function() {
    // Получаем CSRF токен
    const csrfToken = document.querySelector('meta[name="csrf-token"]').content;

    // Лайки постов
    document.querySelectorAll('.like-btn').forEach(button => {
        button.addEventListener('click', async function() {
            const url = this.dataset.url;
            const likesCountSpan = this.querySelector('.likes-count');
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': csrfToken,
                        'Accept': 'application/json'
                    }
                });

                const data = await response.json();
                
                if (data.success) {
                    // Обновляем количество лайков
                    likesCountSpan.textContent = data.likes_count;
                    
                    // Переключаем класс
                    if (data.action === 'added') {
                        this.classList.add('liked');
                    } else {
                        this.classList.remove('liked');
                    }
                }
            } catch (error) {
                console.error('Ошибка:', error);
            }
        });
    });

    // Лайки комментариев (аналогично)
    document.querySelectorAll('.like-btn-comment').forEach(button => {
        button.addEventListener('click', async function() {
            const url = this.dataset.url;
            const likesCountSpan = this.querySelector('span');
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': csrfToken,
                        'Accept': 'application/json'
                    }
                });

                const data = await response.json();
                
                if (data.success) {
                    likesCountSpan.textContent = data.likes_count;
                    
                    if (data.action === 'added') {
                        this.classList.add('liked');
                    } else {
                        this.classList.remove('liked');
                    }
                }
            } catch (error) {
                console.error('Ошибка:', error);
            }
        });
    });
});
```

---

## Часть 12. Политики доступа (Policies)

### Шаг 12.1. Создание Policy

```bash
php artisan make:policy PostPolicy --model=Post
```

Откройте `app/Policies/PostPolicy.php`:

```php
<?php

namespace App\Policies;

use App\Models\Post;
use App\Models\User;

class PostPolicy
{
    /**
     * Может ли пользователь просматривать пост
     */
    public function view(?User $user, Post $post): bool
    {
        // Все могут просматривать посты
        return true;
    }

    /**
     * Может ли пользователь создавать посты
     */
    public function create(User $user): bool
    {
        // Только авторизованные
        return true;
    }

    /**
     * Может ли пользователь редактировать пост
     */
    public function update(User $user, Post $post): bool
    {
        // Только автор
        return $user->id === $post->user_id;
    }

    /**
     * Может ли пользователь удалить пост
     */
    public function delete(User $user, Post $post): bool
    {
        // Только автор
        return $user->id === $post->user_id;
    }
}
```

**Использование в контроллере:**

```php
public function edit(Post $post)
{
    $this->authorize('update', $post);
    return view('posts.edit', compact('post'));
}
```

**Использование в Blade:**

```blade
@can('update', $post)
    <a href="{{ route('posts.edit', $post) }}">Редактировать</a>
@endcan
```

---

## Заключение

В этой лабораторной работе мы создали полноценную систему блогов, изучив:

1. **Миграции** — версионирование структуры БД
2. **Eloquent ORM** — работа с моделями и отношениями
3. **Валидацию через Form Requests** — чистый и переиспользуемый код
4. **Слоистую архитектуру** — разделение бизнес-логики и контроллеров
5. **Middleware** — фильтрация запросов
6. **Фасады** — удобный интерфейс к сервисам
7. **Artisan-команды** — автоматизация задач
8. **Blade-шаблоны** — мощный шаблонизатор
9. **Политики доступа** — авторизация действий

**Следующие шаги для самостоятельного изучения:**

- Добавить категории для постов
- Реализовать полнотекстовый поиск
- Добавить систему тегов

**Полезные ресурсы:**

- Официальная документация Laravel: https://laravel.com/docs
- Laracasts (видеоуроки): https://laracasts.com
- Laravel News: https://laravel-news.com